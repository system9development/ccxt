# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import hashlib
import math
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import AuthenticationError
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class coinstore(Exchange):

    def describe(self):
        return self.deep_extend(super(coinstore, self).describe(), {
            'id': 'coinstore',
            'name': 'Coinstore',
            'countries': ['SG'],
            'rateLimit': 1000,
            'version': 'v1',
            'certified': False,
            'pro': False,
            'has': {
                'CORS': True,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'cancelOrders': False,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': 'emulated',
                'fetchCurrencies': False,
                'fetchDeposits': False,
                'fetchDepositWithdrawFee': False,
                'fetchDepositWithdrawFees': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchLeverage': False,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': False,
                'fetchOpenInterest': False,
                'fetchOpenOrders': 'emulated',
                'fetchOrder': False,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchPositions': False,
                'fetchTicker': False,
                'fetchTickers': True,
                'fetchTime': False,
                'fetchTrades': True,
                'fetchTransfers': False,
                'fetchWithdrawals': False,
                'setLeverage': False,
                'setMargin': False,
                'setMarginMode': False,
                'transfer': False,
            },
            'hostname': 'coinstore.com',
            'urls': {
                'logo': 'https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/253675376-6983b72e-4999-4549-b177-33b374c195e3.jpg',
                'api': {
                    'spot': 'https://api.{hostname}',
                },
                'www': 'https://www.coinstore.com/',
                'doc': 'https://coinstore-openapi.github.io/en/',
                'referral': None,
                'fees': 'https://www.coinstore.com/#/fee',
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'public': {
                    'get': {
                        # Get all tickers
                        'api/v1/market/tickers': 3,
                        # Get public trades
                        'api/v1/market/trade/{symbol}': 3,
                        # Get orderbook
                        'api/v1/market/depth/{symbol}': 3,
                    },
                    'post': {
                        # fetch markets
                        'v2/public/config/spot/symbols': 3,
                    },
                },
                'private': {
                    'get': {
                        # Get open orders
                        'api/v2/trade/order/active': 3,
                        # Fetch all orders
                        'api/trade/order/historyOrders': 3,
                        # Get an individual order
                        'api/v2/trade/order/orderInfo': 3,
                        # fetch user trades
                        'api/trade/match/accountMatches': 3,
                    },
                    'post': {
                        # get balances
                        'api/spot/accountList': 3,
                        # create order
                        'api/trade/order/place': 3,
                        # cancel order
                        'api/trade/order/cancel': 3,
                        # cancel all orders
                        'api/trade/order/cancelAll': 3,
                    },
                },
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1M',
            },
            'fees': {
                'trading': {},
            },
            'precisionMode': TICK_SIZE,
            'exceptions': {
                'exact': {
                    # may be used when a param is missing
                    '400': BadRequest,
                    '401': AuthenticationError,
                    '403': PermissionDenied,
                    '404': BadRequest,
                    '429': DDoSProtection,
                    '500': ExchangeError,
                    '1101': InsufficientFunds,
                    '10001': ExchangeError,
                },
                'broad': {},
            },
            'commonCurrencies': {},
        })

    async def fetch_markets(self, params={}):
        """
         * Uses tickers endpoint since coinstore doesn't have a market data endpoint:
         * https://api.coinstore.com/api/v2/public/config/spot/symbols
         *
        retrieves data on spot markets for coinstore
        see https://coinstore-openapi.github.io/en/#ticker-related
        :param dict [params]: extra parameters specific to the exchange api endpoint
        :returns [dict]: an array of objects representing market data
        """
        response = await self.publicPostV2PublicConfigSpotSymbols()
        data = self.safe_value(response, 'data')
        result = []
        # {
        #     "code": "0",
        #     "message": "Success",
        #     "data": [
        #         {
        #             "symbolId": 1,
        #             "symbolCode": "BTCUSDT",
        #             "tradeCurrencyCode": "btc",
        #             "quoteCurrencyCode": "usdt",
        #             "openTrade": True,
        #             "onLineTime": 1609813531019,
        #             "tickSz": 0,
        #             "lotSz": 4,
        #             "minLmtPr": "0.0002",
        #             "minLmtSz": "0.2",
        #             "minMktVa": "0.1",
        #             "minMktSz": "0.1",
        #             "makerFee": "0.006",
        #             "takerFee": "0.003"
        #         }
        #     ]
        # }
        for i in range(0, len(data)):
            market = data[i]
            # different endpoints use different case for market/currency IDs
            # lowercase everything to be safe
            id = self.safe_string_lower(market, 'symbolCode')
            baseId = self.safe_string_lower(market, 'tradeCurrencyCode')
            quoteId = self.safe_string_lower(market, 'quoteCurrencyCode')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            # symbolId = self.safe_string(market, 'symbolId')
            # if not (symbolId in coinstoreMarketsByNumericId):
            #     coinstoreMarketsByNumericId[symbolId] = symbol
            # }
            lowercaseId = id
            active = self.safe_value(market, 'openTrade')
            pricePrecision = self.safe_number(market, 'tickSz')
            amountPrecision = self.safe_number(market, 'lotSz')
            minSize = self.safe_number(market, 'minLmtSz')
            minPrice = self.safe_number(market, 'minLmtPr')
            entry = {
                'id': id,
                'lowercaseId': lowercaseId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': None,
                'type': 'spot',
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'delivery': False,
                'option': False,
                'active': active != False,
                'contract': False,
                'linear': None,
                'inverse': None,
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': str(self.parse_number(self.parse_precision(amountPrecision))),
                    'price': str(self.parse_number(self.parse_precision(pricePrecision))),
                    'base': None,
                    'quote': None,
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None,
                    },
                    'amount': {
                        'min': minSize,
                        'max': None,
                    },
                    'price': {
                        'min': minPrice,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': market,
            }
            result.append(entry)
        return result

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        """
        get the list of most recent trades for a particular symbol
        see https://coinstore-openapi.github.io/en/#get-user-39-s-latest-trade
        :param str symbol: unified symbol of the market to fetch trades for
        :param number [since]: timestamp used to filter out older trades
        :param number [limit]: the maximum amount of trades to fetch
        :param dict [params:={}] extra parameters specific to the coinstore api endpoint
        :param str [params.ordId]: the order to get trades for
        :param number [params.pageNum]: which page of trades to list
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        self.check_required_symbol('fetchTrades', symbol)
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['size'] = limit
        response = await self.publicGetApiV1MarketTradeSymbol(self.extend(request, params))
        trades = self.safe_value(response, 'data', [])
        return self.parse_trades(trades, market, since)

    def parse_public_trade(self, trade, market=None):
        # public trades:
        # {
        #     "channel": "4@trade",
        #     "time": 1642495112,
        #     "volume": "0.011102",
        #     "price": "41732.3305",
        #     "tradeId": 14867136,
        #     "takerSide": "BUY",
        #     "seq": 14867136,
        #     "ts": 1642495112000,
        #     "symbol": "BTCUSDT",
        #     "instrumentId": 4
        # }
        timestamp = self.safe_number(trade, 'ts')
        symbol = market['symbol']
        price = self.parse_number(self.safe_string(trade, 'price'))
        amount = self.parse_number(self.safe_string(trade, 'volume'))
        cost = None
        if price and amount:
            cost = price * amount
        return self.safe_trade({
            'info': trade,
            'id': self.safe_string(trade, 'tradeId'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': None,
            'type': None,
            'side': self.safe_string(trade, 'takerSide') == 'sell' if 'BUY' else 'buy',
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
        }, market)

    def parse_private_trade(self, trade, market=None):
        # user trades:
        # {
        #     "id": 3984987,
        #     "remainingQty": 0E-18,
        #     "matchRole": 1,
        #     "feeCurrencyId": 44,
        #     "acturalFeeRate": 0.002000000000000000,
        #     "role": 1,
        #     "accountId": 1138204,
        #     "instrumentId": 15,
        #     "baseCurrencyId": 44,
        #     "quoteCurrencyId": 30,
        #     "execQty": 40.900000000000000000,
        #     "orderState": 50,
        #     "matchId": 258338866,
        #     "orderId": 1717384395096065,
        #     "side": 1,
        #     "execAmt": 8.887161000000000000,
        #     "selfDealingQty": 0E-18,
        #     "tradeId": 11523732,
        #     "fee": 0.081800000000000000,
        #     "matchTime": 1637825389,
        #     "seq": null
        # }
        timestamp = self.safe_number(trade, 'matchTime', 0) * 1000
        # Docs claim self is a string 'TAKER' or 'MAKER', but example shows 1
        role = self.safe_string_lower(trade, 'role')
        takerOrMaker = 'maker'
        if role == '1' or role == 'taker':
            takerOrMaker = 'taker'
        # numericId = self.safe_string(trade, 'instrumentId')
        # symbol = self.safe_string(coinstoreMarketsByNumericId, numericId)
        symbol = market['symbol']
        feeCurrencyId = self.safe_number(trade, 'feeCurrencyId')
        baseCurrencyId = self.safe_number(trade, 'baseCurrencyId')
        rate = self.safe_number(trade, 'acturalFeeRate')
        fee = self.safe_number(trade, 'fee')
        feeCurrency = feeCurrencyId == market['base'] if baseCurrencyId else market['quote']
        cost = self.safe_string(trade, 'execAmt')
        amount = self.safe_string(trade, 'execQty')
        price = Precise.string_div(cost, amount)
        order = self.safe_string(trade, 'orderId')
        side = None
        if self.safe_number(trade, 'side') == 1:
            side = 'buy'
        if self.safe_number(trade, 'side') == -1:
            side = 'sell'
        return self.safe_trade({
            'info': trade,
            'id': self.safe_string(trade, 'id'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': order,
            'type': None,
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': self.parse_number(price),
            'amount': self.parse_number(amount),
            'cost': self.parse_number(cost),
            'fee': {
                'cost': fee,
                'currency': feeCurrency,
                'rate': rate,
            },
        }, market)

    def parse_trade(self, trade, market=None):
        if self.safe_string(trade, 'channel'):
            return self.parse_public_trade(trade, market)
        return self.parse_private_trade(trade, market)

    async def fetch_order_book(self, symbol, limit=None, params={}):
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        see https://coinstore-openapi.github.io/en/index.html#get-depth
        :param str symbol: unified symbol of the market to fetch the order book for
        :param number [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the coinstore api endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        self.check_required_symbol('fetchOrderBook', symbol)
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['depth'] = limit
        response = await self.publicGetApiV1MarketDepthSymbol(self.extend(request, params))
        orderbook = self.safe_value(response, 'data', {})
        return self.parse_order_book(orderbook, symbol, Date.now(), 'b', 'a', 0, 1)

    async def fetch_ticker(self, symbol, params={}):
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        see https://coinstore-openapi.github.io/en/#ticker-related
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the coinstore api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        return self.fetch_tickers([symbol], params)

    async def fetch_tickers(self, symbols=None, params={}):
        """
        fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        see https://coinstore-openapi.github.io/en/index.html#ticker
        :param [str]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict [params]: extra parameters specific to the coinstore api endpoint
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        ids = list(self.markets_by_id.keys())
        for i in range(0, len(ids)):
            ids[i] = ids[i].upper()
        response = await self.publicGetApiV1MarketTickers(params)
        # We need to filter out tickers for markets that are not in the market list(coinstore doesn't return all markets in the market info endpoint)
        tickers = self.filter_by_array(self.safe_value(response, 'data'), 'symbol', ids)
        return self.parse_tickers(tickers, symbols)

    def parse_ticker(self, ticker, market=None):
        # {
        #     "channel": "ticker",
        #     "bidSize": "454.2",
        #     "askSize": "542.6",
        #     "count": 41723,
        #     "volume": "24121351.85",
        #     "amount": "1693799.10798965",
        #     "close": "0.067998",
        #     "open": "0.071842",
        #     "high": "0.072453",
        #     "low": "0.067985",
        #     "bid": "0.0679",
        #     "ask": "0.0681",
        #     "symbol": "TRXUSDT",
        #     "instrumentId": 2
        # }
        marketId = self.safe_string_lower(ticker, 'symbol')
        market = self.market(marketId)
        open = self.safe_number(ticker, 'open')
        high = self.safe_number(ticker, 'high')
        low = self.safe_number(ticker, 'low')
        close = self.safe_number(ticker, 'close')
        last = close
        quoteVolume = self.safe_number(ticker, 'volume')
        baseVolume = self.safe_number(ticker, 'amount')
        bid = self.safe_number(ticker, 'bid')
        ask = self.safe_number(ticker, 'ask')
        change = open - close
        vwap = quoteVolume / baseVolume
        average = (open + close) / 2
        percentage = (change / open) * 100
        return self.safe_ticker({
            'symbol': market['symbol'],
            'timestamp': None,
            'datetime': None,
            'high': high,
            'low': low,
            'bid': bid,
            'bidVolume': None,
            'ask': ask,
            'askVolume': None,
            'vwap': vwap,
            'open': open,
            'close': close,
            'last': last,
            'previousClose': None,
            'change': change,
            'percentage': percentage,
            'average': average,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }, market)

    async def fetch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        see https://coinstore-openapi.github.io/en/#assets-balance
        :param dict [params]: extra parameters specific to the conistore api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        await self.load_markets()
        response = await self.privatePostApiSpotAccountList()
        return self.parse_balance(response)

    def parse_balance(self, response):
        balances = self.safe_value(response, 'data', [])
        result = {'info': response}
        for i in range(0, len(balances)):
            balance = balances[i]
            type = self.safe_number(balance, 'type')
            currencyId = self.safe_string_lower(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.safe_value(result, code, self.account())
            if type == 1:
                # self is the 'available' balance
                account['free'] = self.safe_number(balance, 'balance', 0)
                account['used'] = self.safe_number(account, 'used', 0)
            elif type == 4:
                account['used'] = self.safe_number(balance, 'balance', 0)
                account['free'] = self.safe_number(account, 'free', 0)
            result[code] = account
        return self.safe_balance(result)

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        """
        create a trade order
        see https://coinstore-openapi.github.io/en/#create-order
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param number amount: how much of currency you want to trade in units of base currency
        :param number [price]: the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the coinstore api endpoint
        :param str [params.clOrdId]: a custom order ID
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.check_required_symbol('createOrder', symbol)
        await self.load_markets()
        request = {
            'symbol': self.market_id(symbol),
            'ordType': type.upper(),
            'side': side.upper(),
        }
        if request['ordType'] == 'LIMIT':
            request['ordPrice'] = self.price_to_precision(symbol, price)
        if request['ordType'] == 'MARKET' and side.lower() == 'buy':
            ordAmt = self.safe_number(params, 'ordAmt')
            if amount is not None:
                raise BadRequest(self.id + ' createOrder() does not support the amount parameter for market buy orders, for the amount of quote currency to spend use the ordAmt parameter')
            if not ordAmt:
                raise BadRequest(self.id + ' createOrder() requires an ordAmt parameter for market buy orders, for the amount of quote currency to spend')
            request['ordAmt'] = self.price_to_precision(symbol, ordAmt)
        else:
            request['ordQty'] = self.amount_to_precision(symbol, amount)
        request['timestamp'] = self.milliseconds()
        response = await self.privatePostApiTradeOrderPlace(self.extend(request, params))
        return self.parse_submitted_order(request, response)

    async def cancel_order(self, id, symbol=None, params={}):
        """
        cancels an open order
        see https://coinstore-openapi.github.io/en/index.html#cancel-orders
        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the coinstore api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.check_required_argument('cancelOrder', symbol, 'symbol')
        self.check_required_argument('cancelOrder', id, 'id')
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'ordId': id,
        }
        response = await self.privatePostApiTradeOrderCancel(self.extend(request, params))
        return self.parse_canceled_order(request, response)

    async def cancel_all_orders(self, symbol=None, params={}):
        """
        cancel all open orders
        see https://coinstore-openapi.github.io/en/index.html#one-click-cancellation
        :param str|None [symbol]: unified market symbol, only orders in the market of self symbol are cancelled when symbol is not None
        :param dict [params]: extra parameters specific to the coinstore api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        request = {}
        if symbol:
            market = self.market(symbol)
            request['symbol'] = market['id']
        # timestamp = Date.now()
        # The response for self endpoint is empty, so to return the correct information we should
        # response =
        await self.privatePostApiTradeOrderCancelAll(self.extend(request, params))
        # The endpoint used by fetchOrders only returns open orders apparently
        # They don't have a documented endpoint for all orders
        # try:
        #     orders = await self.fetch_orders(symbol, timestamp)
        #     return self.filter_by(orders, 'status', 'canceled')
        # except Exception as e:
        #     # return an empty array; the fetchOrders call failed, but cancelation succeeded
        #     return []
        # }
        return []

    def parse_canceled_order(self, request, response):
        # request:
        # {
        #    "symbol": "btcusdt",
        #    "ordId": 1722183748419690
        # }
        #
        # response:
        # {
        #     "code": 0,
        #     "data": {
        #         "clientOrderId": "b1b2ea5e00a84b888d419cb73f8eb203",
        #         "state": "CANCELED",
        #         "ordId": 1722183748419690
        #     }
        # }
        data = self.safe_value(response, 'data')
        orderId = self.safe_value(data, 'ordId')
        symbol = self.safe_string(request, 'symbol')
        market = self.market(symbol)
        info = self.extend({'request': request}, {'response': response})
        return self.safe_order({
            'info': info,
            'id': orderId,
            'symbol': symbol,
            'status': 'canceled',
        }, market)

    def parse_submitted_order(self, request, response):
        # response(docs are wrong):
        # {
        #     "code": "0",
        #     "data": {
        #         "ordId": 11594964764657880
        #     }
        # }
        orderId = self.safe_number(response, 'ordId')
        info = self.extend({'request': request}, {'response': response})
        marketId = self.safe_string_lower(request, 'symbol')
        market = self.market(marketId)
        symbol = market['symbol']
        side = self.safe_string_lower(request, 'side')
        type = self.safe_string_lower(request, 'ordType')
        price = self.safe_number(request, 'ordPrice')
        amount = self.safe_number(request, 'ordQty')
        return self.safe_order({
            'info': info,
            'id': orderId,
            'symbol': symbol,
            'side': side,
            'type': type,
            'price': price,
            'amount': amount,
        }, market)

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        """
         * @namecoinstore#fetchOrders
        see https://coinstore-openapi.github.io/en/#get-current-orders-v2
        fetch all open orders orders
        :param str|None symbol: unified market symbol
        :param int|None [since]: the earliest time in ms to fetch open orders for
        :param int [limit]: the maximum number of open order structures to retrieve
        :param dict [params]: extra parameters specific to the coinstore api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if limit is not None:
            request['size'] = limit
        response = await self.privateGetApiTradeOrderHistoryOrders(self.extend(request, params))
        data = self.safe_value(response, 'data')
        orders = self.safe_value(data, 'list', [])
        parsedOrders = self.parse_orders(orders, market)
        if since is not None or limit is not None:
            return self.filter_by_since_limit(parsedOrders, since, limit)
        return parsedOrders

    def parse_order(self, order, market=None):
        # history response format:
        # {
        #     "baseCurrency": "USDC",
        #     "quoteCurrency": "USDT",
        #     "side": "SELL",
        #     "cumQty": "22",
        #     "ordId": 1773897094529949,
        #     "clOrdId": "0",
        #     "ordType": "LIMIT",
        #     "ordQty": "98.48",
        #     "cumAmt": "21.7752",
        #     "timeInForce": "GTC",
        #     "ordPrice": "0.9896",
        #     "leavesQty": "0",
        #     "avgPrice": "0.9898",
        #     "ordState": "CANCELED",
        #     "symbol": "USDCUSDT",
        #     "timestamp": 1691720096406,
        #     "accountId": 3643140,
        #     "feeCurrency": "USDT",
        #     "ordAmt": "97.455808"
        # },
        # active response format:
        # {
        #     "baseCurrency": "A123",
        #     "quoteCurrency": "USDT",
        #     "side": "BUY",
        #     "cumQty": "0",
        #     "ordId": 1758065956225025,
        #     "clOrdId": "tLCGVA4g19zuEBwsITXi9g3U624Al0Bw",
        #     "ordType": "LIMIT",
        #     "ordQty": "10",
        #     "cumAmt": "0",
        #     "accountId": 1134912,
        #     "timeInForce": "GTC",
        #     "ordPrice": "100",
        #     "leavesQty": "10",
        #     "avgPrice": "0",
        #     "ordStatus": "SUBMITTED",
        #     "symbol": "A123USDT",
        #     "timestamp": 1676622290389
        # }
        timestamp = self.safe_number(order, 'timestamp')
        feeCurrency = self.safe_string(order, 'feeCurrency')
        fee = None
        if feeCurrency:
            fee = {
                'currency': self.safe_currency_code(feeCurrency),
            }
        filledAmount = self.safe_string(order, 'cumQty', '0')
        filledAmountNumber = self.parse_number(filledAmount)
        amount = self.safe_string(order, 'ordQty')
        cost = self.safe_string(order, 'cumAmt')
        remaining = Precise.string_sub(amount, filledAmount)
        average = filledAmountNumber != Precise.string_div(cost, filledAmount) if 0 else None
        return self.safe_order({
            'info': order,
            'id': self.safe_string(order, 'ordId'),
            'clientOrderId': self.safe_string(order, 'clOrdId'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': self.safe_symbol(self.safe_string_lower(order, 'symbol'), market),
            'type': self.safe_string_lower(order, 'ordType'),
            'timeInForce': 'GTC',
            'postOnly': None,
            'side': self.safe_string_lower('order', 'side'),
            'price': self.safe_number(order, 'ordPrice'),
            'stopPrice': None,
            'triggerPrice': None,
            'amount': self.parse_number(amount),
            'filled': filledAmountNumber,
            'remaining': self.parse_number(remaining),
            'average': self.parse_number(average) if average else None,
            'status': self.parse_order_status(self.safe_string_2(order, 'ordStatus', 'ordState')),
            'trades': None,
            'fee': fee,
        }, market)

    def parse_order_status(self, status):
        statuses = {
            'REJECTED': 'rejected',
            'SUBMITTING': 'open',
            'SUBMITTED': 'open',
            'PARTIAL_FILLED': 'open',
            'CANCELING': 'canceled',
            'CANCELED': 'canceled',
            'EXPIRED': 'expired',
            'STOPPED': 'closed',
            'FILLED': 'closed',
        }
        return self.safe_string(statuses, status, status)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetch all unfilled currently open orders
        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch open orders for
        :param int [limit]: the maximum number of open order structures to retrieve
        :param dict [params]: extra parameters specific to the coinstore api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        # parsedOrders = await self.fetch_orders(symbol, None, None, params)
        # filteredOrders = self.filter_by(parsedOrders, 'status', 'open')
        # if since is not None or limit is not None:
        #     return self.filter_by_since_limit(filteredOrders, since, limit)
        # }
        # return filteredOrders
        await self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        response = await self.privateGetApiV2TradeOrderActive(self.extend(request, params))
        data = self.safe_value(response, 'data')
        parsedOrders = self.parse_orders(data, market)
        if since is not None or limit is not None:
            return self.filter_by_since_limit(parsedOrders, since, limit)
        return parsedOrders

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetches information on multiple closed orders made by the user
        :param str [symbol]: unified market symbol of the market orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        parsedOrders = await self.fetch_orders(symbol, None, None, params)
        filteredOrders = self.filter_by_array(parsedOrders, 'status', ['canceled', 'rejected', 'expired', 'closed'])
        if since is not None or limit is not None:
            return self.filter_by_since_limit(filteredOrders, since, limit)
        return filteredOrders

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        """
        get the list of most recent trades for a particular symbol
        see https://coinstore-openapi.github.io/en/#get-user-39-s-latest-trade
        :param str symbol: unified symbol of the market to fetch trades for
        :param number [since]: timestamp used to filter out older trades
        :param number [limit]: the maximum amount of trades to fetch
        :param dict [params:={}] extra parameters specific to the coinstore api endpoint
        :param str [params.ordId]: the order to get trades for
        :param number [params.pageNum]: which page of trades to list
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        await self.load_markets()
        self.check_required_symbol('fetchMyTrades', symbol)
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['pageSize'] = limit
        response = await self.privateGetApiTradeMatchAccountMatches(self.extend(request, params))
        trades = self.safe_value(response, 'data', [])
        # tradesParsed = self.parse_trades(trades, market, since)
        return self.parse_trades(trades, market, since)

    def sign(self, path, api='public', method='GET', params={}, headers={}, body=None):
        """
        signs and initiates the request
        see https://coinstore-openapi.github.io/en/#signature-authentication
        :param str path: the path to be appended to the URL
         * @param {'GET' | 'POST'} method extra parameters specific to the coinstore api endpoint
        :param dict [params]: parameters to use for the path(for v1 symbols) or the query string
        :param dict [headers]: headers to use for the request
        :param dict [body]: body to use for the request
        :returns dict: an associative dictionary of currencies
        """
        url = getattr(self, 'urls')['api']['spot']
        url = self.implode_hostname(url)
        # v1 api implodes 'symbol' for some endpoints
        path = self.implode_params(path, params)
        url += '/' + path
        params = self.omit(params, self.extract_params(path))
        params = self.keysort(params)
        paramString = ''
        bodyString = ''
        if method == 'GET':
            paramString = self.urlencode(params)
        else:
            bodyString = json.dumps(params)
        if len(paramString):
            url += '?' + paramString
        headers['Content-Type'] = 'application/json'
        if api == 'private':
            self.check_required_credentials()
            timestamp = self.milliseconds()
            # timestamp = 1691200987053
            headers['X-CS-EXPIRES'] = str(timestamp)
            headers['X-CS-APIKEY'] = self.apiKey
            expiresKey = int(math.floor(timestamp / 30000))
            expiresHmac = self.hmac(self.encode str((expiresKey)), self.encode(self.secret), hashlib.sha256, 'hex')
            headers['X-CS-SIGN'] = self.hmac(self.encode(paramString + bodyString), self.encode(expiresHmac), hashlib.sha256, 'hex')
        if method == 'POST':
            return {'url': url, 'method': method, 'body': bodyString, 'headers': headers}
        return {'url': url, 'method': method, 'headers': headers}
        # if body == 0:
        # }
        # return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def nonce(self):
        return self.milliseconds()

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if code is not None:
            self.throw_exactly_matched_exception(self.exceptions['exact'], code, reason)
        if response is None:
            return None  # fallback to default error handler
        responseCode = self.safe_number(response, 'code')
        if responseCode != 0:
            message = self.safe_string(response, 'message')
            self.throw_exactly_matched_exception(self.exceptions['exact'], responseCode, message)
            raise BadRequest(self.id + ' failed with code ' + responseCode + ' and message ' + message + '. Check your arguments and parameters')
