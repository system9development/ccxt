# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import hashlib
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import DuplicateOrderId
from ccxt.base.errors import InvalidNonce
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class pintu(Exchange):

    def describe(self):
        return self.deep_extend(super(pintu, self).describe(), {
            'id': 'pintu',
            'name': 'Pintu',
            'countries': ['ID'],  # Indonesia
            'rateLimit': 1000,
            'version': 'v1',
            'certified': False,
            'pro': False,
            'has': {
                'CORS': False,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'cancelAllOrders': False,
                'cancelOrder': True,
                'cancelOrders': False,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': 'emulated',
                'fetchCurrencies': False,
                'fetchDeposits': False,
                'fetchDepositWithdrawFee': False,
                'fetchDepositWithdrawFees': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchLeverage': False,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': False,
                'fetchOpenInterest': False,
                'fetchOpenOrders': True,
                'fetchOrder': False,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchPositions': False,
                'fetchTicker': False,  # not available
                'fetchTickers': False,  # not available
                'fetchTime': False,
                'fetchTrades': False,
                'fetchTransfers': False,
                'fetchWithdrawals': False,
                'setLeverage': False,
                'setMargin': False,
                'setMarginMode': False,
                'transfer': False,
            },
            'hostname': 'uat.pintupro.com',
            'urls': {
                'logo': 'https://docs.pintupro.com/images/logo-76f33bf1.png',
                'api': {
                    'spot': 'https://api.{hostname}/v1',
                },
                'www': 'https://pintu.co.id/en',
                'doc': 'https://docs.pintupro.com/',
                'referral': None,
                'fees': 'https://pintu.co.id/en/fees',
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'public': {
                    'get': {
                        'public/get-symbols-reference': 1,  # fetch markets
                        'public/get-book': 1,
                    },
                },
                'private': {
                    'post': {
                        'private/place-order': 1,  # create order
                        'private/cancel-order': 1,
                        'private/get-account-information': 1,  # get balances
                        'private/get-open-orders': 1,
                        'private/get-order-history': 1,
                        'private/get-order-details': 1,
                        'private/get-trade-history': 1,
                    },
                },
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1M',
            },
            'fees': {
                'trading': {},
            },
            'precisionMode': TICK_SIZE,
            'exceptions': {
                'exact': {
                    '1': BadSymbol,
                    '2': BadRequest,
                    '3': InvalidOrder,
                    '4': ExchangeError,
                    '7': OrderNotFound,
                    '8': ExchangeError,
                    '11': InsufficientFunds,
                    '12': InvalidNonce,
                },
                'broad': {
                    # code 2, http 400:
                    'page size': BadRequest,  # page size should be 1 to 200
                    'order id': InvalidOrder,  # empty order ID and client order ID
                    'should be greater': BadRequest,  # TEnd should be greater than TStart
                    'within 24': BadRequest,  # TStart and TEnd should be within 24 hours
                    'is required': ArgumentsRequired,  # symbol or tradeIds is required
                    'must be greater than 0': BadRequest,  # Amount must be greater than 0
                    'must be greater than zero': BadRequest,  # Amount must be greater than 0
                    'must be greater than minimum': BadRequest,  # Amount must be greater than 0
                    'duplicate request id': DuplicateOrderId,  # Duplicate request ID
                    'invalid asset': BadSymbol,  # Invalid asset
                    # code 3, http 200:
                    'exceeded maximum order size': InvalidOrder,  # Exceeded maximum order size.
                    'insufficient': InvalidOrder,  # Insufficient order size.
                    'should be specified': ArgumentsRequired,  # both TStart and TEnd should be specified
                    'invalid price': InvalidOrder,  # Invalid price or Too many decimals.
                    'too many decimals': InvalidOrder,  # Invalid price or Too many decimals.
                    'far away limit price': InvalidOrder,  # Far away limit price.
                    'exceeded trading daily limit': PermissionDenied,  # Exceeded trading daily limit.
                    'max number of open orders.': PermissionDenied,  # Max number of open orders.
                },
            },
            'commonCurrencies': {},
        })

    async def fetch_markets(self, params={}):
        """
        *
       retrieves data on spot markets for pintu
       see https://docs.pintupro.com/#get-symbol-reference
       :param dict [params]: extra parameters specific to the exchange api endpoint
       :returns [dict]: an array of objects representing market data
       """
        response = await self.publicGetPublicGetSymbolsReference()
        data = self.safe_value(response, 'data')
        data = self.safe_value(data, 'symbols', [])
        result = []
        # {
        #   "code": 0,
        #   "message": "SUCCESS",
        #   "reason": "",
        #   "data": {
        #     "symbols": [
        #       {
        #         "symbol": "BTC-USDT",
        #         "quote_asset": "USDT",
        #         "base_asset": "BTC",
        #         "price_decimals": 7,
        #         "size_decimals": 0,
        #         "max_size": "1000000000",
        #         "min_size": "10",
        #         "max_value": "85000000",
        #         "min_value": "10000",
        #         "max_price": "1000",
        #         "min_price": "0.0000001",
        #         "quantity_tick_size": "10",
        #         "price_tick_size": "0.0000001",
        #         "last_updated_at": 1666261193053
        #       },
        #       ...
        for i in range(0, len(data)):
            market = data[i]
            id = self.safe_string(market, 'symbol')
            baseId = self.safe_string(market, 'base_asset')
            quoteId = self.safe_string(market, 'quote_asset')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            lowercaseId = id.lower()
            active = True
            # review self:
            pricePrecisionDecimals = self.safe_string(market, 'price_decimals')
            amountPrecisionDecimals = self.safe_string(market, 'size_decimals')
            pricePrecision = self.safe_number(market, 'price_tick_size')
            amountPrecision = self.safe_number(market, 'quantity_tick_size')
            if self.parse_number(self.parse_precision(pricePrecisionDecimals)) > pricePrecision:
                pricePrecision = self.parse_number(self.parse_precision(pricePrecisionDecimals))
            if self.parse_number(self.parse_precision(amountPrecisionDecimals)) > amountPrecision:
                amountPrecision = self.parse_number(self.parse_precision(pricePrecisionDecimals))
            minSize = self.safe_number(market, 'min_size')
            minPrice = self.safe_number(market, 'min_price')
            maxSize = self.safe_number(market, 'max_size')
            maxPrice = self.safe_number(market, 'max_price')
            minCost = self.safe_number(market, 'min_value')
            maxCost = self.safe_number(market, 'max_value')
            entry = {
                'id': id,
                'lowercaseId': lowercaseId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': None,
                'type': 'spot',
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'delivery': False,
                'option': False,
                'active': active,
                'contract': False,
                'linear': None,
                'inverse': None,
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': amountPrecision,
                    'price': pricePrecision,
                    'base': None,
                    'quote': None,
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None,
                    },
                    'amount': {
                        'min': minSize,
                        'max': maxSize,
                    },
                    'price': {
                        'min': minPrice,
                        'max': maxPrice,
                    },
                    'cost': {
                        'min': minCost,
                        'max': maxCost,
                    },
                },
                'info': market,
            }
            result.append(entry)
        return result

    async def fetch_order_book(self, symbol, limit=None, params={}):
        """
       fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
       see https://docs.pintupro.com/#get-book
       :param str symbol: unified symbol of the market to fetch the order book for
       :param number [limit]: the maximum amount of order book entries to return
       :param dict [params]: extra parameters specific to the pintu api endpoint
       :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
       """
        self.check_required_symbol('fetchOrderBook', symbol)
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['depth'] = limit
        response = await self.publicGetPublicGetBook(self.extend(request, params))
        timestamp = self.safe_timestamp(response, 'timestamp')
        orderbook = self.safe_value(response, 'data', {})
        return self.parse_order_book(orderbook, symbol, timestamp, 'bids', 'asks', 0, 1)

    async def fetch_balance(self, params={}):
        """
       query for balance and get the amount of funds available for trading or funds locked in orders
       see https://pintu-openapi.github.io/en/#assets-balance
       :param dict [params]: extra parameters specific to the pintu api endpoint
       :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
       """
        await self.load_markets()
        response = await self.privatePostPrivateGetAccountInformation()
        return self.parse_balance(response)

    def parse_balance(self, response):
        # {
        #   "code": 0,
        #   "message": "SUCCESS",
        #   "data": {
        #     "assets": {
        #       "btc": {
        #         "balance": "10",
        #         "available": "8",
        #         "order": "2"
        #       },
        #       "eth": {
        #         "balance": "32",
        #         "available": "30",
        #         "order": "2",
        #       }
        #
        # }
        data = self.safe_value(self.safe_value(response, 'data', {}), 'assets', {})
        currencyIds = list(data.keys())
        timestamp = self.safe_timestamp(response, 'timestamp')
        result = {
            'info': response,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
        }
        for i in range(0, len(currencyIds)):
            currencyId = currencyIds[i]
            symbol = self.safe_currency_code(currencyId)
            balance = self.safe_value(data, currencyId, {})
            account = self.account()
            account['free'] = self.safe_string(balance, 'available')
            account['used'] = self.safe_string(balance, 'order')
            account['total'] = self.safe_string(balance, 'balance')
            result[symbol] = account
        return self.safe_balance(result)

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        """
       create a new order
       see https://docs.pintupro.com/#place-order
       :param str symbol: unified symbol of the market to create an order in
       :param str type: 'market' or 'limit'
       :param str side: 'buy' or 'sell'
       :param number amount: how much of currency you want to trade in units of base currency, ignored in market buy orders
       :param number [price]: the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
       :param dict [params]: extra parameters specific to the pintu api endpoint
       :param str [params.client_order_id]: a custom order ID
       :param number [params.notional]: for market buy orders only, notional must be specified instead of amount
       :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
       """
        self.check_required_symbol('createOrder', symbol)
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'type': type.upper(),
            'side': side.upper(),
        }
        if type == 'limit':
            request['price'] = self.price_to_precision(symbol, price)
        if type == 'market' and side == 'buy':
            notional = self.safe_number(params, 'notional')
            if amount is not None:
                raise BadRequest(self.id + ' createOrder() does not support the amount parameter for market buy orders, for the amount of quote currency to spend use the notional parameter')
            if not notional or Number.isNaN(notional):
                raise BadRequest(self.id + ' createOrder() requires a notional parameter for market buy orders, for the amount of quote currency to spend')
            request['notional'] = self.price_to_precision(symbol, notional)
        else:
            request['size'] = self.amount_to_precision(symbol, amount)
        response = await self.privatePostPrivatePlaceOrder(self.extend(request, params))
        timestamp = self.safe_timestamp(response, 'timestamp')
        responseData = self.safe_value(response, 'data', {})
        return self.safe_order({
            'info': responseData,
            'id': self.safe_string(responseData, 'order_id'),
            'clientOrderId': self.safe_string(responseData, 'client_order_id'),
            'symbol': symbol,
            'side': side,
            'type': type,
            'price': request['price'],
            'amount': request['size'],
            'notional': request['notional'],
            'timestamp': timestamp,
        }, market)

    async def cancel_order(self, id, symbol, params={}):
        """
       cancels an open order
       see https://docs.pintupro.com/#cancel-order
       :param str id: order id
       :param str symbol: unified symbol of the market the order was made in
       :param dict [params]: extra parameters specific to the pintu api endpoint
       :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
       """
        self.check_required_symbol('cancelOrder', symbol)
        self.check_required_argument('cancelOrder', id, 'id')
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'order_id': id,
        }
        await self.privatePostPrivateCancelOrder(self.extend(request, params))
        # {
        #     "request_id": "a88b9054-bde2-4fd7-8a4e-c6ff6de212e2",
        #     "timestamp": 16775774798300,
        #     "method": "private/cancel-order",
        #     "code": 0,
        #     "message": "SUCCESS"
        # }
        return self.safe_order({
            'id': id,
            'symbol': symbol,
            'status': 'canceled',
        }, market)

    async def fetch_orders(self, symbol, since=None, limit=None, params={}):
        """
       see https://docs.pintupro.com/#get-order-history
       fetch all open orders orders
       :param str|None symbol: unified market symbol
       :param number|None [since]: the earliest time in ms to fetch open orders for
       :param number [limit]: the maximum number of open order structures to retrieve
       :param dict [params]: extra parameters specific to the pintu api endpoint
       :param number [params.page]: which page of orders to list
       :param number [params.t_end]: timestamp to fetch orders until, defaults to now. Required if specified with 'since', must be max 24 hours from since
       :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
       """
        self.check_required_symbol('fetchOrders', symbol)
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if since is not None:
            until = self.safe_number(params, 't_end')
            difference = until - since
            maxDifference = self.parse_timeframe('1d') * 1000
            if not until or Number.isNaN(difference) or difference <= 0 or difference > maxDifference:
                raise BadRequest(self.id + ' fetchOrders() requires a t_end parameter to be specified with since, and must be max 24 hours from since')
            request['t_start'] = since
            request['t_end'] = until
        if limit is not None:
            # pagination can be controlled with params.page, e.g. {page: 2}
            request['page_size'] = limit
        response = await self.privatePostPrivateGetOrderHistory(self.extend(request, params))
        # {
        #     "request_id": "a88b9054-bde2-4fd7-8a4e-c6ff6de212e2",
        #     "timestamp": 16775774798300,
        #     "method": "private/get-order-history",
        #     "code": 0,
        #     "message": "SUCCESS",
        #     "data": {
        #       "orders": [
        #         {
        #           "status": "PARTIALLY_FILLED",
        #           "symbol": "BTC-IDRT",
        #           "type": "LIMIT",
        #           "time_in_force": "GTC",
        #           "exec_inst": "POST_ONLY",
        #           "side": "BUY",
        #           "price": "15000",
        #           "size": "2",
        #           "cum_price": "15000",
        #           "cum_size": "0.35",
        #           "cum_value": "5250",
        #           "order_id": "12345678-abcd-efgh-ijkl-1234567890ab",
        #           "client_order_id": "my-order-id-1",
        #           "created_at": 16775774795300,
        #           "updated_at": 16775774797678
        #         },
        #         ...
        #       ]
        #     }
        #   }
        orders = self.safe_value(self.safe_value(response, 'data', {}), 'orders', [])
        return self.parse_orders(orders, market)

    def parse_order(self, order, market):
        # history + open order response format:
        # {
        #   "status": "PARTIALLY_FILLED",
        #   "symbol": "BTC-IDRT",
        #   "type": "LIMIT",
        #   "time_in_force": "GTC",
        #   "exec_inst": "POST_ONLY",
        #   "side": "BUY",
        #   "price": "15000",
        #   "size": "2",
        #   "cum_price": "15000",
        #   "cum_size": "0.35",
        #   "cum_value": "5250",
        #   "order_id": "12345678-abcd-efgh-ijkl-1234567890ab",
        #   "client_order_id": "my-order-id-1",
        #   "created_at": 16775774795300,
        #   "updated_at": 16775774797678
        # }
        updateTimestamp = self.safe_number(order, 'updated_at', 0)
        createdTimestamp = self.safe_number(order, 'created_at', 0)
        clientOrderId = self.safe_string(order, 'client_order_id')
        side = self.safe_string_lower(order, 'side')
        type = self.safe_string_lower(order, 'type')
        symbol = market['symbol']
        amount = self.safe_number(order, 'size')
        price = self.safe_number(order, 'price')
        filledAmount = self.safe_string(order, 'cum_size', '0')
        status = self.parse_order_status(self.safe_string(order, 'status'))
        cost = self.safe_string(order, 'cum_value')
        average = self.safe_string(order, 'cum_price')
        orderResponse = {
            'info': order,
            'id': self.safe_string(order, 'order_id'),
            'clientOrderId': clientOrderId,
            'symbol': symbol,
            'timestamp': createdTimestamp,
            'datetime': self.iso8601(createdTimestamp),
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'timeInForce': self.safe_string(order, 'time_in_force'),
            'postOnly': self.safe_string(order, 'exec_inst') == 'POST_ONLY',
            'filled': self.parse_number(filledAmount),
            'remaining': str(self.parse_number(Precise.string_sub(amount), filledAmount)),
            'cost': cost,
            'status': status,
        }
        if average and average != '0':
            orderResponse['average'] = self.parse_number(average)
            if status == 'open' or status == 'closed':
                orderResponse['lastTradeTimestamp'] = updateTimestamp
        return self.safe_order(orderResponse, market)

    def parse_order_status(self, status):
        statuses = {
            'REJECTED': 'rejected',
            'PLACED': 'open',
            'PARTIALLY_FILLED': 'open',
            'FILLED': 'closed',
            'CANCELED': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    async def fetch_open_orders(self, symbol, since=None, limit=None, params={}):
        """
       see https://docs.pintupro.com/#get-open-orders
       fetch all unfilled currently open orders
       :param str symbol: unified market symbol
       :param number [since]: the earliest time in ms to fetch open orders for
       :param number [limit]: the maximum number of open order structures to retrieve
       :param dict [params]: extra parameters specific to the pintu api endpoint
       :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
       """
        self.check_required_symbol('fetchOpenOrders', symbol)
        await self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        response = await self.privatePostPrivateGetOpenOrders(self.extend(request, params))
        # "data": {
        #     "count": 345,
        #     "orders": [
        #       {
        #         "status": "PARTIALLY_FILLED",
        #         "symbol": "BTC-IDRT",
        #         "type": "LIMIT",
        #         "time_in_force": "GTC",
        #         "exec_inst": "POST_ONLY",
        #         "side": "BUY",
        #         "price": "15000",
        #         "size": "2",
        #         "cum_price": "15000",
        #         "cum_size": "0.35",
        #         "cum_value": "5250",
        #         "order_id": "12345678-abcd-efgh-ijkl-1234567890ab",
        #         "client_order_id": "my-order-id-1",
        #         "created_at": 16775774795300,
        #         "updated_at": 16775774797678
        #       },
        #       ...
        #     ]
        # }
        orders = self.safe_value(self.safe_value(response, 'data', {}), 'orders', [])
        if since is not None or limit is not None:
            orders = self.filter_by_since_limit(orders, since, limit, 'created_at')
        return self.parse_orders(orders, market)

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        """
       fetches information on multiple closed orders made by the user
       :param str [symbol]: unified market symbol of the market orders were made in
       :param number [since]: the earliest time in ms to fetch orders for
       :param number [limit]: the maximum number of order structures to retrieve
       :returns [dict]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
       """
        parsedOrders = await self.fetch_orders(symbol, None, None, params)
        filteredOrders = self.filter_by_array(parsedOrders, 'status', ['canceled', 'rejected', 'expired', 'closed'], False)
        if since is not None or limit is not None:
            return self.filter_by_since_limit(filteredOrders, since, limit)
        return filteredOrders

    async def fetch_my_trades(self, symbol, since=None, limit=None, params={}):
        """
       get the list of most recent trades for a particular symbol
       see https://docs.pintupro.com/#get-trade-history
       :param str symbol: unified symbol of the market to fetch trades for
       :param number [since]: timestamp used to filter out older trades
       :param number [limit]: the maximum amount of trades to fetch
       :param dict [params:={}] extra parameters specific to the pintu api endpoint
       :param number [params.page]: which page of trades to list
       :param number [params.t_end]: timestamp to fetch trades until, defaults to now. Required if specified with 'since', must be max 24 hours from since
       :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
       """
        self.check_required_symbol('fetchMyTrades', symbol)
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if since is not None:
            until = self.safe_number(params, 't_end')
            difference = until - since
            maxDifference = self.parse_timeframe('1d') * 1000
            if not until or Number.isNaN(difference) or difference <= 0 or difference > maxDifference:
                raise BadRequest(self.id + ' fetchMyTrades() requires a t_end parameter to be specified with since, and must be max 24 hours from since')
            request['t_start'] = since
            request['t_end'] = until
        if limit is not None:
            # pagination can be controlled with params.page, e.g. {page: 2}
            request['page_size'] = limit
        response = await self.privatePostPrivateGetTradeHistory(self.extend(request, params))
        trades = self.safe_value(self.safe_value(response, 'data', {}), 'trades', [])
        return self.parse_trades(trades, market, since)

    def parse_trade(self, trade, market):
        # {
        #     "request_id": "a88b9054-bde2-4fd7-8a4e-c6ff6de212e2",
        #     "timestamp": 16775774797463,
        #     "method": "private/get-trade-history",
        #     "code": "0",
        #     "message": "SUCCESS",
        #     "data": {
        #         "trades": [
        #             {
        #                 "trade_id": "my-trade-id",
        #                 "order_id": "my-order-id",
        #                 "symbol": "BTC-IDR",
        #                 "side": "buy",
        #                 "price": "350000000",
        #                 "fee": "0.001",
        #                 "fee_asset": "BTC",
        #                 "fee_type": "maker",
        #                 "client_order_id": "my-client-order-id",
        #                 "traded_size": "0.905",
        #                 "traded_at": 1676869976772
        #             },
        #             ...
        #         ]
        #     }
        # }
        timestamp = self.safe_number(trade, 'traded_at', 0)
        role = self.safe_string_lower(trade, 'fee_type')
        takerOrMaker = 'maker'
        if role == 'taker':
            takerOrMaker = 'taker'
        symbol = market['symbol']
        feeCurrency = self.currency(self.safe_string(trade, 'fee_asset')).code
        fee = self.safe_number(trade, 'fee')
        amount = self.safe_number(trade, 'traded_size')
        price = self.safe_number(trade, 'price')
        cost = str(self.parse_number(Precise.string_mul(amount), str(price)))
        rate = str(Precise.string_div(fee), str(amount))
        if feeCurrency == market['quote']:
            rate = str(Precise.string_div(fee), str(cost))
        order = self.safe_string(trade, 'order_id')
        clientOrderId = self.safe_string(trade, 'client_order_id')
        tradeId = self.safe_string(trade, 'trade_id')
        side = self.safe_string_lower(trade, 'side')
        return self.safe_trade({
            'info': trade,
            'id': tradeId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': order,
            'type': None,
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': price,
            'amount': amount,
            'cost': cost,
            'clientOrderId': clientOrderId,
            'fee': {
                'cost': fee,
                'currency': feeCurrency,
                'rate': rate,
            },
        }, market)

    async def fetch_order(self, id, symbol, params={}):
        """
       fetches information on an order made by the user
       :param str symbol: unified symbol of the market the order was made in
       :param dict params: extra parameters specific to the pintu api endpoint
       :param str [params.client_order_id]: The client order id of the order(if provided without an id)
       :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
       """
        self.check_required_symbol('fetchOrder', symbol)
        market = self.market(symbol)
        symbolId = market['id']
        clientOrderId = self.safe_string(params, 'client_order_id')
        if not id and not clientOrderId:
            raise BadRequest(self.id + ' fetchOrder() requires either an order id or params.client_order_id')
        await self.load_markets()
        request = {
            'symbol': symbolId,
        }
        if clientOrderId:
            request['client_order_id'] = clientOrderId
        else:
            request['order_id'] = id
        response = await self.privatePostPrivateGetOrderDetails(self.extend(request, params))
        data = self.safe_value(response, 'data', {})
        orderInfo = self.safe_value(data, 'order_info', {})
        parsedOrder = self.parse_order(orderInfo, market)
        tradesInfo = self.safe_value(data, 'trades_info', [])
        for i in range(0, len(tradesInfo)):
            trade = tradesInfo[i]
            trade['order_id'] = parsedOrder['id']
            if parsedOrder['clientOrderId']:
                trade['client_order_id'] = parsedOrder['clientOrderId']
        parsedTrades = self.parse_trades(tradesInfo, market)
        parsedOrder['trades'] = parsedTrades
        parsedOrder['info'] = response
        return parsedOrder

    def sign(self, path, api='public', method='GET', params={}, headers={}, body={}):
        """
       signs and initiates the request
       see https://docs.pintupro.com/#api-messages-format-specification
       see https://docs.pintupro.com/#api-signature-computation
       :param str path: the path to be appended to the URL
        * @param {'GET' | 'POST'} method extra parameters specific to the pintu api endpoint
       :param dict [params]: parameters to use for the path(for v1 symbols) or the query string
       :param dict [headers]: headers to use for the request
       :param dict [body]: body to use for the request
       :returns dict: an associative dictionary of currencies
       """
        urls = self.safe_value(self, 'urls')
        apiUrls = self.safe_value(urls, 'api')
        url = self.safe_string(apiUrls, 'spot', '')
        url = self.implode_hostname(url)
        url += '/' + path
        params = self.keysort(params)
        headers['Accept'] = 'application/json'
        headers['Host'] = 'api.uat.pintupro.com'
        if api == 'public':
            paramString = self.urlencode(params)
            if len(paramString):
                paramString = '?' + paramString
            return {'url': url + paramString, 'method': method, 'headers': headers}
        headers['Content-Type'] = 'application/json'
        self.check_required_credentials()
        paramString = ''
        keys = list(params.keys())
        for i in range(0, len(keys)):
            key = keys[i]
            value = self.safe_string(params, key, '')
            paramString += key + value
        requestId = self.uuid()
        timestamp = self.milliseconds()
        signString = requestId + str(timestamp) + path + self.apiKey + paramString
        signature = self.hmac(self.encode(signString), self.encode(self.secret), hashlib.sha256, 'hex')
        body = {
            'api_key': self.apiKey,
            'method': path,
            'params': params,
            'request_id': requestId,
            'signature': signature,
            'timestamp': timestamp,
        }
        # private API always uses POST
        return {'url': url, 'method': method, 'body': json.dumps(body), 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return None  # fallback to default error handler
        responseCode = self.safe_string(response, 'code')
        if responseCode != '0':
            message = self.safe_string(response, 'message', '') + ': ' + self.safe_string(response, 'reason', '')
            messageLower = self.safe_string_lower(response, 'message', '') + ': ' + self.safe_string_lower(response, 'reason', '')
            self.throw_broadly_matched_exception(self.exceptions['broad'], messageLower, message)
            self.throw_exactly_matched_exception(self.exceptions['exact'], responseCode, message)
            raise BadRequest(self.id + ' failed with code ' + responseCode + ' and message ' + message + '. Check your arguments and parameters')
