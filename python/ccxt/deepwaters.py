# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadSymbol
from ccxt.base.decimal_to_precision import TRUNCATE
from ccxt.base.decimal_to_precision import DECIMAL_PLACES
from ccxt.base.precise import Precise


class deepwaters(Exchange):

    def describe(self):
        return self.deep_extend(super(deepwaters, self).describe(), {
            'id': 'deepwaters',
            'name': 'Deepwaters',
            'countries': ['US'],
            'rateLimit': 5,
            'certified': False,
            'version': 'v1',
            'has': {
                'CORS': None,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'cancelAllOrders': True,                       # DELETE /orders?pair= (pair is optional)
                'cancelOrder': True,                           # DELETE /orders/by-venue-order-id/:orderId
                'createOrder': True,                           # POST /orders
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': False,
                'fetchBalance': True,                          # GET /customer {.result.balances[]}
                'fetchBidsAsks': True,
                'fetchBorrowRate': False,
                'fetchBorrowRateHistories': False,
                'fetchBorrowRateHistory': False,
                'fetchBorrowRates': False,
                'fetchBorrowRatesPerSymbol': False,
                'fetchClosedOrders': True,                      # GET /orders?status-in=FILLED&pair=XXX(pair is optional, returns max 100 orders)
                'fetchCanceledOrders': True,                    # GET /orders?status-in=CANCELLED&pair=XXX(pair is optional, returns max 100 orders)
                'fetchCurrencies': True,                        # GET /assets
                'fetchDepositAddress': False,
                'fetchDeposits': False,
                'fetchMarginMode': False,
                'fetchMarkets': True,                           # GET /pairs
                'fetchMyTrades': True,                          # GET /trades?pair=:marketName(pair is optional, returns max 100 results)
                'fetchOHLCV': False,                            # Currently not supported
                'fetchOpenOrders': True,                        # GET /orders?status-in=ACTIVE-PARTIALLY_FILLED&pair=XXX(pair is optional, returns max 100 orders)
                'fetchOrder': True,                             # GET /orders/by-venue-order-id/:orderId
                'fetchOrderBook': True,                         # GET /pairs/:marketId/orderbook
                'fetchOrders': True,                            # GET /orders?pair=:marketId(pair is optional, returns max 100 orders)
                'fetchPositionMode': False,
                'fetchStatus': False,                           # could maybe use customer endpoint?
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': False,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTransactionFees': False,
                'fetchTransactions': False,
                'fetchTransfers': False,
                'fetchWithdrawals': False,
                'transfer': False,
                'withdraw': False,
            },
            'timeframes': None,
            'urls': {
                'test': {
                    'public': 'https://testnet.api.deepwaters.xyz/rest/v1',
                    'private': 'https://testnet.api.deepwaters.xyz/rest/v1',
                },
                'api': {
                    'public': 'https://api.deepwaters.xyz/rest/v1',
                    'private': 'https://api.deepwaters.xyz/rest/v1',
                },
                'www': 'https://deepwaters.xyz',
                'referral': '',
                'doc': [
                    'https://rest.docs.api.deepwaters.xyz/',
                ],
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.001,
                    'taker': 0.0015,
                    # 'feeside': TODO
                    'feeSide': 'get',
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'public': {
                    'get': [
                        'assets',
                        'pairs',
                        'pairs/{pair}/orderbook',
                        'time',
                    ],
                },
                'private': {
                    'get': {
                        'customer': 1,
                        'customer/api-key-status': 1,
                        'orders': 1,
                        'trades': 1,
                        'orders/by-venue-order-id/{id}': 1,
                        'orders/by-customer-object-id/{id}': 1,
                    },
                    'post': {
                        'orders': 1,
                    },
                    'delete': {
                        'orders': 1,
                        'orders/by-venue-order-id/{id}': 1,
                        'orders/by-customer-object-id/{id}': 1,
                    },
                },
            },
            'precisionMode': DECIMAL_PLACES,
        })

    def fetch_bids_asks(self, symbols=None, params={}):
        """
        fetches the bid and ask price and volume for multiple markets
        :param [str]|None symbols: unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        return self.fetch_tickers(symbols, params)

    def fetch_ticker(self, symbol, params={}):
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        if not symbol:
            raise ArgumentsRequired('symbol must be provided to deepwaters#fetchTicket()')
        tickers = self.fetch_tickers([symbol])
        if len(tickers) == 0:
            raise BadSymbol('Symbol not found. Is it available in  deepwaters#fetchMarkets()?')
        return tickers[symbol]

    def fetch_tickers(self, symbols=None, params={}):
        """
        fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        :param [str]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        self.load_markets()
        symbols = self.market_symbols(symbols)
        response = self.publicGetPairs()
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        markets = self.safe_value(response, 'result', {})
        tickers = []
        for i in range(0, len(markets)):
            # {
            #     baseAssetRootSymbol: 'AVAX',
            #     quoteAssetRootSymbol: 'USDC',
            #     baseAssetParentSymbol: 'WAVAX.DW',
            #     quoteAssetParentSymbol: 'USDC.DW',
            #     baseAssetID: 'WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD',
            #     quoteAssetID: 'USDC.AVALANCHE_FUJI.43113.TESTNET.PROD',
            #     name: 'WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD-USDC.AVALANCHE_FUJI.43113.TESTNET.PROD',
            #     baseAssetIncrementSize: '.01',
            #     baseAssetIncrementPrecision: '2',
            #     quoteAssetIncrementSize: '.001',
            #     quoteAssetIncrementPrecision: '3',
            #     createdAtMicros: '1677695274781348',
            #     quotedAtMicros: '1677838210968536',
            #     ask: '16.418',
            #     bid: '16.396'
            # }
            market = markets[i]
            base = self.safe_value(market, 'baseAssetRootSymbol')
            quote = self.safe_value(market, 'quoteAssetRootSymbol')
            symbol = base + '/' + quote
            quotedAtMicros = self.safe_value(market, 'quotedAtMicros')
            timestamp = self.parse_number(Precise.string_div(quotedAtMicros, '1000', 0))
            datetime = self.iso8601(timestamp)
            ask = self.safe_number(market, 'ask')
            bid = self.safe_number(market, 'bid')
            tickers.append(self.safe_ticker({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': datetime,
                'ask': ask,
                'bid': bid,
                'info': market,
            }))
        return self.filter_by_array(tickers, 'symbol', symbols)

    def fetch_markets(self, params={}):
        """
        retrieves data on all markets for deepwaters
        :returns [dict]: an array of objects representing market data
        """
        response = self.publicGetPairs()
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        # {
        #     "success": True,
        #     "result": [
        #       {
        #         "baseAssetRootSymbol": "ETH",
        #         "quoteAssetRootSymbol": "USDC",
        #         "baseAssetParentSymbol": "WETH.DW",
        #         "quoteAssetParentSymbol": "USDC.DW",
        #         "baseAssetID": "WETH_EM_MB",
        #         "quoteAssetID": "USDC_EM_MB",
        #         "name": "WETH_EM_MB-USDC_EM_MB",
        #         "baseAssetIncrementSize": ".00001",
        #         "baseAssetIncrementPrecision": 5,
        #         "quoteAssetIncrementSize": ".01",
        #         "quoteAssetIncrementPrecision": 2,
        #         "createdAtMicros": 1677434515360241,
        #         "quotedAtMicros": 1677452326283803,
        #         "ask": "1636.39",
        #         "bid": "1631.15"
        #       },
        #       ...
        markets = self.safe_value(response, 'result')
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = self.safe_string(market, 'name')
            lowercaseId = self.safe_string_lower(market, 'name')
            exchangeBaseId = self.safe_string(market, 'baseAssetID')
            exchangeQuoteId = self.safe_string(market, 'quoteAssetID')
            baseId = self.safe_string(market, 'baseAssetRootSymbol')
            quoteId = self.safe_string(market, 'quoteAssetRootSymbol')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            pricePrecision = self.safe_string(market, 'quoteAssetIncrementPrecision')
            amountPrecision = self.safe_string(market, 'baseAssetIncrementPrecision')
            entry = {
                'id': id,
                'lowercaseId': lowercaseId,
                'symbol': base + '/' + quote,
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': exchangeBaseId,
                'quoteId': exchangeQuoteId,
                'settleId': None,
                'type': 'spot',
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'active': True,
                'contract': False,
                'linear': None,
                'inverse': None,
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': self.parse_number(self.parse_precision(amountPrecision)),
                    'price': self.parse_number(self.parse_precision(pricePrecision)),
                    # base and quote precisions not defined
                    'cost': None,
                },
                # Docs don't explain what the order limits are
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None,
                    },
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': market,
            }
            if base != quote:
                # Don't push self market if base and quote are the same
                # This is currently only True on testnet which has several USDC/USDC markets
                result.append(entry)
        return result

    def get_nonce(self):
        if not self.dwnonce:
            return 0
        return self.dwnonce

    def fetch_nonce(self):
        response = self.privateGetCustomerApiKeyStatus()
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        nonce = self.safe_string(result, 'nonce', '0')
        self.dwnonce = self.parse_number(nonce)

    def fetch_currencies(self, params={}):
        """
        Fetches all available currencies an exchange and returns an associative dictionary of currencies.
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a dictionary of `currency structure <https://docs.ccxt.com/en/latest/manual.html#currency-structure>`
        """
        response = self.publicGetAssets()
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        # {
        #     "success": True,
        #     "result": [
        #       {
        #         "chainID": 1,
        #         "chainName": "ETHEREUM_MAINNET",
        #         "assetAddress": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        #         "rootSymbol": "USDC",
        #         "assetID": "USDC_EM_MB",
        #         "parentSymbol": "USDC.DW",
        #         "frontEndSymbol": "USDC",
        #         "name": "USD Coin",
        #         "ticker": "USDC",
        #         "frontEndName": "",
        #         "uiDecimals": 2,
        #         "databaseDecimals": 25,
        #         "contractDecimals": 6,
        #         "createdAtMicros": 1677434515342102
        #       },
        #       ...
        currencies = self.safe_value(response, 'result', {})
        result = {}
        for i in range(0, len(currencies)):
            currency = currencies[i]
            id = self.safe_string(currency, 'assetID')
            code = self.safe_string(currency, 'rootSymbol')
            precision = self.parse_number(self.parse_precision(self.safe_string(currency, 'uiDecimals')))
            # assumes all currencies are active except those listed above
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': code,
                'active': True,
                'deposit': None,
                'withdraw': None,
                'fee': None,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': precision,
                        'max': None,
                    },
                    'withdraw': {
                        'min': None,
                        'max': None,
                    },
                },
            }
        return result

    def parse_balance(self, response):
        timestamp = self.milliseconds()
        result = {
            'info': response,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
        }
        responseResult = self.safe_value(response, 'result', {})
        responseBalances = self.safe_value(responseResult, 'balances', [])
        balances = self.is_array responseBalances if (responseBalances) else []
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'assetID')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['total'] = self.safe_number(balance, 'amount')
            result[code] = account
        return self.safe_balance(result)

    def parse_order_status(self, status):
        statuses = {
            'CANCELLED': 'canceled',
            'REJECTED': 'rejected',
            'ACTIVE': 'open',
            'FILLED': 'closed',
            'PARTIALLY_FILLED': 'open',
            'EXPIRED': 'closed',
        }
        return self.safe_string(statuses, status, None)

    def parse_order(self, order, market=None):
        # console.log('parseorder', order, market)
        if market is None:
            baseId = self.safe_string(order, 'baseAssetID')
            base = self.safe_currency_code(baseId)
            quoteId = self.safe_string(order, 'quoteAssetID')
            quote = self.safe_currency_code(quoteId)
            if (not(quoteId in self.currencies_by_id)) and (quoteId.find('USDC') == 0):
                # Their testnet has multiple USDC currencies with different IDs.
                # This causes the currencies list USDC entry to be overwritten when currencies
                # are parsed, which means the above will have an None quote.
                # As of right now, there isn't any ambiguity with mainnet currencies
                quote = 'USDC'
            marketSymbol = base + '/' + quote
            market = self.market(marketSymbol)
        status = self.parse_order_status(self.safe_string(order, 'status'))
        # Deepwaters appears to have 2 unique IDs per order: customerObjectID and
        # venueOrderID. customerObjectID is something the user can set, but is otherwise
        # autogenerated
        id = self.safe_string(order, 'venueOrderID')
        clientOrderId = self.safe_string(order, 'customerObjectID')
        createdTimestampMicros = self.safe_string(order, 'createdAtMicros')
        updatedTimestampMicros = self.safe_string(order, 'modifiedAtMicros')
        createdTimestampMs = None
        updatedTimestampMs = None
        if createdTimestampMicros:
            createdTimestampMs = Precise.string_div(createdTimestampMicros, '1000', 0)
        if updatedTimestampMs:
            updatedTimestampMs = Precise.string_div(updatedTimestampMicros, '1000', 0)
        timeInForce = 'GTC'
        if self.safe_string(order, 'durationType') == 'GOOD_TILL_EXPIRY':
            # GTE doesn't seem to be used anywhere else in ccxt,
            # but deepwaters' api has a distinction
            timeInForce = 'GTE'
        type = 'limit'
        if self.safe_string(order, 'type') == 'MARKET':
            type = 'market'
        side = 'buy'
        if self.safe_string(order, 'side') == 'SELL':
            side = 'sell'
        price = self.safe_string(order, 'price')
        remaining = self.safe_string(order, 'quantity')
        amount = self.safe_string(order, 'originalQuantity')
        filled = Precise.string_sub(amount, remaining)
        parsedOrder = {
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': self.parse_number(createdTimestampMs),
            'datetime': self.iso8601(createdTimestampMs),
            'symbol': market['symbol'],
            'type': type,
            'timeInForce': timeInForce,
            'side': side,
            'price': self.parse_number(price),
            'amount': self.parse_number(amount),
            'filled': self.parse_number(filled),
            'remaining': self.parse_number(remaining),
            'status': status,
            'trades': None,
            # 'average': self.parse_number(average), TODO
            # 'cost': self.parse_number(cost), TODO
            'fee': None,  # Not available via API
            'stopPrice': None,  # N/A
            'triggerPrice': None,  # N/A
            'postOnly': None,  # N/A
        }
        if status == 'closed':
            parsedOrder['lastTradetimestamp'] = self.parse_number(updatedTimestampMs)
        if (status == 'open') and (amount != remaining):
            parsedOrder['lastTradeTimestamp'] = self.parse_number(updatedTimestampMs)
        return self.safe_order(parsedOrder, market)

    def fetch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        self.load_markets()
        response = self.privateGetCustomer()
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        # {
        #     customerAddress: '0x4db55abc5e7532439501bc6aed40b6281382959a',
        #     nonce: '1',
        #     createdAtMicros: '1677829125843454',
        #     modifiedAtMicros: '1677829125843553',
        #     lastCustomerObjectID: null,
        #     balances: []
        # }
        result = self.safe_value(response, 'result', {})
        balances = self.safe_value(result, 'balances')
        modifiedAtMicros = self.safe_value(result, 'modifiedAtMicros')
        timestamp = self.parse_number(Precise.string_div(modifiedAtMicros, '1000', 0))
        datetime = self.iso8601(timestamp)
        output = {
            'timestamp': timestamp,
            'datetime': datetime,
            'info': result,
            'free': {},
            'used': {},
            'total': {},
        }
        for i in range(0, len(balances)):
            # {
            #     'amount': 'string',
            #     'assetID': 'string',
            #     'serviceDescription': 'string',
            #     'serviceName': 'string'
            # }
            balance = balances[i]
            currencyId = self.safe_value(balance, 'assetID')
            currency = self.safe_value(self.currencies_by_id, currencyId)
            if not currency:
                # self is only needed in sandbox mode, if you get airdrops
                continue
            currencyCode = self.safe_value(currency, 'code')
            if not output[currencyCode]:
                output[currencyCode] = {
                    'used': '0',
                    'free': '0',
                }
                output['used'][currencyCode] = '0'
                output['free'][currencyCode] = '0'
            amount = self.safe_value(balance, 'amount')
            serviceName = self.safe_value(balance, 'serviceName')
            if serviceName == 'accounting.available':
                output[currencyCode]['free'] = amount
                output['free'][currencyCode] = amount
            elif serviceName == 'fee' or serviceName == 'swap.engine':
                used = Precise.string_add(output[currencyCode]['used'], amount)
                output[currencyCode]['used'] = used
                output['used'][currencyCode] = used
        keys = list(output['used'].keys())
        for i in range(0, len(keys)):
            key = keys[i]
            total = Precise.string_add(output['used'][key], output['free'][key])
            output['total'][key] = total
            output[key]['total'] = total
        return self.safe_balance(output)

    def fetch_order_book(self, symbol, limit=None, params={}):
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int|None limit: the maximum amount of order book entries to return
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/en/latest/manual.html#order-book-structure>` indexed by market symbols
        """
        self.load_markets()
        market = self.market(symbol)
        request = {
            'pair': market['id'],
        }
        if limit is not None:
            request['depth'] = limit
        response = self.publicGetPairsPairOrderbook(self.extend(request, params))
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        #
        # {
        #   snapshotAtMicros: '1641562961192',
        #   asks: [
        #     {price: '0.921', quantity: '76.01', depth: 0},
        #     {price: '0.933', quantity: '477.10', depth: 1},
        #     ...
        #   ],
        #   bids: [
        #     {price: '0.940', quantity: '13502.47', depth: 0},
        #     {price: '0.932', quantity: '43.91', depth: 1},
        #     ...
        #   ]
        # }
        #
        timestampMicros = self.safe_string(result, 'snapshotAtMicros', '0')
        timestamp = self.parse_number(Precise.string_div(timestampMicros, '1000', 0))
        return self.parse_order_book(result, symbol, timestamp, 'bids', 'asks', 'price', 'quantity')

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetches information on multiple orders made by the user
        :param str|None symbol: unified market symbol of the market orders were made in
        :param int|None since: the earliest time in ms to fetch orders for
        :param int|None limit: the maximum number of  orde structures to retrieve
        :param dict params: extra parameters specific to the bybit api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        request = {}
        if symbol is not None:
            market = self.market(symbol)
            request['pair'] = market['id']
        if since is not None:
            since = Precise.string_mul(self.decimal_to_precision(since, TRUNCATE, self.markets[symbol]['precision']['amount']), '1000')
            request['created-at-or-after-micros'] = since
        if limit is not None:
            limit = self.decimal_to_precision(limit, TRUNCATE, self.markets[symbol]['precision']['amount'])
            request['limit'] = limit
        response = self.privateGetOrders(self.extend(request, params))
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        orders = self.safe_value(result, 'orders', [])
        # success = self.safe_value(response, 'success', False)
        return self.parse_orders(orders)

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        """
        fetch all trades made by the user
        :param str symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades structures to retrieve
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html#trade-structure>`
        """
        self.load_markets()
        request = {
            # 'pair': '',
            # 'type': '',
            # 'created-at-or-after-micros': '',
            # 'created-before-micros': '',
            # 'skip': '',
            'limit': 100,
        }
        if symbol is not None:
            market = self.market(symbol)
            request['pair'] = market['id']
        if since is not None:
            since = Precise.string_mul(self.decimal_to_precision(since, TRUNCATE, self.markets[symbol]['precision']['amount']), '1000')
            request['created-at-or-after-micros'] = since
        if limit is not None:
            limit = self.decimal_to_precision(limit, TRUNCATE, self.markets[symbol]['precision']['amount'])
            request['limit'] = limit
        type = self.safe_string(params, 'type')
        if isinstance(type, str):
            params = self.omit(params, 'type')
            if type.upper() == 'LIMIT':
                request['type'] = 'LIMIT'
            if type.upper() == 'MARKET':
                # Getting the following error right now with type == 'MARKET' despite what the docs say
                #     handleRestResponse:
                #     deepwaters GET https://testnet.api.deepwaters.xyz/rest/v1/trades?limit=10&pair=WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD-USDC.AVALANCHE_FUJI.43113.TESTNET.PROD&created-at-or-after-micros=1677982036376000&type=MARKET 400 Bad Request
                #    ResponseHeaders:
                #     {
                #      'Alt-Svc': 'h3=":443"; ma=2592000',
                #      Connection: 'close',
                #      'Content-Length': '112',
                #      'Content-Type': 'application/json; charset=utf-8',
                #      Date: 'Sun, 05 Mar 2023 05:27:16 GMT',
                #      Server: 'Caddy',
                #      Vary: 'Origin'
                #    }
                #    ResponseBody:
                #     {"success":false,"status":"invalid request","error":"MARKET is an invalid type. Valid are: FILL, PARTIAL_FILL"}
                request['type'] = 'PARTIAL_FILL'
        response = self.privateGetTrades(self.extend(request, params))
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        trades = self.safe_value(result, 'trades', [])
        output = []
        for i in range(0, len(trades)):
            # {
            #     "aggressorCustomerObjectID": "string",
            #     "aggressorFeesTotalValueInQuoteAsset": "string",
            #     "aggressorFeesQuoteAssetAmount": "string",
            #     "aggressorFeesWTRAmount": "string",
            #     "aggressorRemainingQuantity": "string",
            #     "aggressorVenueOrderID": "string",
            #     "baseAssetID": "string",
            #     "createdAtMicros": 0,
            #     "makerCustomerObjectID": "string",
            #     "makerFeesTotalValueInQuoteAsset": "string",
            #     "makerFeesQuoteAssetAmount": "string",
            #     "makerFeesWTRAmount": "string",
            #     "makerRemainingQuantity": "string",
            #     "makerVenueOrderID": "string",
            #     "makerWasBuyer": True,
            #     "price": "string",
            #     "quantity": "string",
            #     "quoteAssetID": "string",
            #     "tradeID": "string",
            #     "tradeType": "FILL",
            #     "userWasAggressor": True,
            #     "userWasMaker": True
            # }
            trade = trades[i]
            id = self.safe_value(trade, 'tradeID')
            createdAtMicros = self.safe_string(trade, 'createdAtMicros')
            timestamp = self.parse_number(Precise.string_div(createdAtMicros, '1000', 0))
            datetime = self.iso8601(timestamp)
            baseAssetID = self.safe_value(trade, 'baseAssetID')
            quoteAssetID = self.safe_value(trade, 'quoteAssetID')
            market = self.market(baseAssetID + '-' + quoteAssetID)
            symbol = self.safe_value(market, 'symbol')
            makerWasBuyer = self.safe_value(market, 'makerWasBuyer')
            userWasMaker = self.safe_value(market, 'userWasMaker')
            maker = 'maker' if userWasMaker else 'taker'
            orderId = None
            if maker:
                orderId = self.safe_string(trade, 'makerVenueOrderID')
            else:
                orderId = self.safe_string(trade, 'aggressorVenueOrderID')
            side = userWasMaker == 'buy' if makerWasBuyer else 'sell'
            price = self.safe_number(trade, 'price')
            amount = self.safe_number(trade, 'quantity')
            cost = Precise.string_mul(self.safe_string(trade, 'price'), self.safe_string(trade, 'quantity'))
            userWasAggressor = self.safe_value(market, 'userWasAggressor')
            type = 'market' if userWasAggressor else 'limit'
            output.append(self.safe_trade({
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': datetime,
                'symbol': symbol,
                'order': orderId,
                'type': type,
                'side': side,
                'takerOrMaker': maker,
                'price': price,
                'amount': amount,
                'cost': cost,
            }))
        return output

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        suppliedFilters = self.safe_string(params, 'status-in', '').split('-')
        constructedFilters = ['ACTIVE', 'PARTIALLY_FILLED']
        remainingAvailableFilters = ['FILLED', 'REJECTED', 'CANCELLED', 'EXPIRED']
        for i in range(0, len(remainingAvailableFilters)):
            filter = remainingAvailableFilters[i]
            if self.in_array(filter, suppliedFilters):
                constructedFilters.append(filter)
        params = self.extend(params, {'status-in': '-'.join(constructedFilters)})
        # console.log(symbol, since, limit, params)
        return self.fetch_orders(symbol, since, limit, params)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        suppliedFilters = self.safe_string(params, 'status-in', '').split('-')
        constructedFilters = ['FILLED']
        remainingAvailableFilters = ['ACTIVE', 'REJECTED', 'CANCELLED', 'EXPIRED', 'PARTIALLY_FILLED']
        for i in range(0, len(remainingAvailableFilters)):
            filter = remainingAvailableFilters[i]
            if self.in_array(filter, suppliedFilters):
                constructedFilters.append(filter)
        params = self.extend(params, {'status-in': '-'.join(constructedFilters)})
        return self.fetch_orders(symbol, since, limit, params)

    def fetch_canceled_orders(self, symbol=None, since=None, limit=None, params={}):
        suppliedFilters = self.safe_string(params, 'status-in', '').split('-')
        constructedFilters = ['CANCELLED']
        remainingAvailableFilters = ['ACTIVE', 'REJECTED', 'CANCELLED', 'EXPIRED', 'PARTIALLY_FILLED']
        for i in range(0, len(remainingAvailableFilters)):
            filter = remainingAvailableFilters[i]
            if self.in_array(filter, suppliedFilters):
                constructedFilters.append(filter)
        params = self.extend(params, {'status-in': '-'.join(constructedFilters)})
        return self.fetch_orders(symbol, since, limit, params)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        """
        create an order
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float|None price: the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        durationType = self.safe_string(params, 'durationType', 'GOOD_TILL_CANCEL')
        orderType = type.upper()
        market = self.market(symbol)
        orderSide = side.upper()
        customerObjectId = self.safe_string(params, 'customerObjectId')
        expiresAtMicros = self.safe_number(params, 'expiresAtMicros', 0)
        expiresIn = self.safe_value(params, 'expiresIn', '')
        precisionQuantity = self.amount_to_precision(symbol, amount)
        # {
        #     "baseAssetID": "string",
        #     "customerObjectID": "string",
        #     "durationType": "GOOD_TILL_CANCEL",
        #     "expiresAtMicros": 0,
        #     "expiresIn": "string",
        #     "price": "string",
        #     "quantity": "string",
        #     "quoteAssetID": "string",
        #     "side": "BUY",
        #     "type": "LIMIT"
        #   }
        request = {
            'baseAssetID': market['baseId'],
            'durationType': durationType,
            'customerObjectID': customerObjectId,
            'type': orderType,
            'side': orderSide,
            'quoteAssetID': market['quoteId'],
            'quantity': precisionQuantity,
        }
        if type == 'limit':
            precisionPrice = self.price_to_precision(symbol, price)
            request['price'] = precisionPrice
            if durationType == 'GOOD_TILL_EXPIRY':
                request['expiresIn'] = expiresIn if expiresIn else None
                request['expiresAtMicros'] = expiresAtMicros if expiresAtMicros else null
        self.fetch_nonce()
        response = self.privatePostOrders(request)
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        # Market Order
        # {
        #     status: 'FILLED',
        #     respondedAtMicros: '1677872186295635',
        #     venueOrderID: '0x85b3e1dd0c9f4609a3b611f991c54c51d85ab510745b11a039af52c0bab46b1a',
        #     originalQuantity: '1.00',
        #     quantity: '0.00'
        # }
        # Limit Order
        result = self.safe_value(response, 'result', {})
        id = self.safe_string(result, 'venueOrderID')
        respondedAtMicros = self.safe_string(result, 'respondedAtMicros')
        timestamp = self.parse_number(Precise.string_div(respondedAtMicros, '1000', 0))
        datetime = self.iso8601(timestamp)
        exchangeStatus = self.safe_value(result, 'status')
        status = self.parse_order_status(exchangeStatus)
        originalQuantity = self.safe_string(result, 'originalQuantity')
        order = {
            'id': id,
            'timestamp': timestamp,
            'datetime': datetime,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'amount': originalQuantity,
            'info': result,
        }
        if exchangeStatus == 'FILLED':
            order['filled'] = originalQuantity
        if type == 'limit':
            order['price'] = price
        return self.safe_order(order)

    def fetch_order(self, id, symbol=None, params={}):
        # params and symbol are unused
        self.load_markets()
        params = {
            'id': id,
        }
        if not isinstance(id, str):
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a string id')
        isVenueId = id[0:2] == '0x'
        response = None
        if isVenueId:
            response = self.privateGetOrdersByVenueOrderIdId(params)
        else:
            response = self.privateGetOrdersByCustomerObjectIdId(params)
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        return self.parse_order(result)

    def cancel_order(self, id, symbol=None, params={}):
        """
        cancels an open order
        :param str id: order id
        :param str symbol: unused
        :param dict params: unused
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        self.fetch_nonce()
        params = {
            'id': id,
        }
        if not isinstance(id, str):
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a string id')
        isVenueId = id[0:2] == '0x'
        response = None
        if isVenueId:
            response = self.privateDeleteOrdersByVenueOrderIdId(params)
        else:
            response = self.privateDeleteOrdersByCustomerObjectIdId(params)
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        # Deepwaters doesn't respond with any order information on cancelation
        result = self.safe_value(response, 'result')
        respondedAtMicros = self.safe_value(result, 'respondedAtMicros')
        timestamp = self.parse_number(Precise.string_div(respondedAtMicros, '1000', 0))
        datetime = self.iso8601(timestamp)
        order = {
            'status': 'canceled',
            'id': id,
            'datetime': datetime,
            'timestamp': timestamp,
            'symbol': symbol,
            'info': result,
        }
        return self.safe_order(order)

    def cancel_all_orders(self, symbol=None, params={}):
        self.load_markets()
        self.fetch_nonce()
        if symbol:
            market = self.market(symbol)
            pairParam = {
                'pair': market.id,
            }
            params = self.extend(params, pairParam)
        response = self.privateDeleteOrders(params)
        # EXAMPLE response
        # {
        #     "result": {
        #       "numCancelled": 0,
        #       "respondedAtMicros": 0
        #     },
        #     "success": True
        #   }
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        return self.safe_value(response, 'result', {})

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        """
        Signs an api request to deepwaters exchange
        see https://rest.docs.api.deepwaters.xyz/cutting_edge/index.html
       """
        # Get array of params which need to be substituted in path
        pathParams = self.extract_params(path)
        # self is the path with any variable segments substituted from provided params
        # currently only relevant for 'pairs/{marketId}/orderbook', which isn't signed
        path = '/' + self.implode_params(path, params)
        # Remove params which were substituted in path, important for signing
        params = self.omit(params, pathParams)
        nonce = ''
        bodyString = ''
        if api == 'private':
            headers = {}
            timestamp = self.number_to_string(self.microseconds() + 10)
            self.check_required_credentials()
            if (method == 'GET') or (method == 'DELETE'):
                keys = list(params.keys())
                if len(keys):
                    path = path + '?' + self.urlencode(params)
            if (method == 'POST') or (method == 'DELETE'):
                if method == 'POST':
                    body = params
                    bodyString = json.dumps(body)
                nonce = self.number_to_string(self.get_nonce())
                postDeleteHeaders = {
                    'content-type': 'application/json',
                    'X-DW-NONCE': nonce,
                }
                headers = self.extend(headers, postDeleteHeaders)
            message = method + '/rest/v1' + path.lower() + timestamp + nonce + bodyString
            # calculate signature
            signature = self.sign_hash(self.hash(message, 'keccak'), self.secret)
            signature.v = signature.v - 27
            vByte = signature.v.toString(16)
            if len(vByte) == 1:
                vByte = '0' + vByte
            signatureString = signature.r + signature.s[2:] + vByte
            sigHeaders = {
                'X-DW-APIKEY': self.apiKey,
                'X-DW-TSUS': timestamp,
                'X-DW-SIGHEX': signatureString,
            }
            headers = self.extend(headers, sigHeaders)
        url = self.urls['api'][api] + path
        if len(bodyString):
            return {'url': url, 'method': method, 'body': bodyString, 'headers': headers}
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_error(self, response={}):
        error = self.safe_string(response, 'error', '')
        code = self.safe_string(response, 'code', '')
        status = self.safe_string(response, 'status', '')
        raise ExchangeError(code + ': ' + error + ' ' + status)

    def fetch_time(self, params={}):
        """
        fetches the current integer timestamp in milliseconds from the deepwaters server
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns int: the current integer timestamp in milliseconds from the deepwaters server
        """
        response = self.publicGetTime()
        success = self.safe_value(response, 'success', False)
        if not success:
            raise self.handle_error(response)
        timestampMicros = self.safe_value(response, 'timestampMicros')
        timestamp = self.parse_number(Precise.string_div(timestampMicros, '1000', 0))
        return timestamp

    def sign_hash(self, hash, privateKey):
        signature = self.ecdsa(hash[-64:], privateKey[-64:], 'secp256k1', None)
        return {
            'r': '0x' + signature['r'],
            's': '0x' + signature['s'],
            'v': 27 + signature['v'],
        }
