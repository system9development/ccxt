<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\deepwaters as Exchange;
use ccxt\ExchangeError;
use ccxt\ArgumentsRequired;
use ccxt\BadSymbol;
use ccxt\Precise;
use React\Async;

class deepwaters extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'deepwaters',
            'name' => 'Deepwaters',
            'countries' => array( 'US' ),
            'rateLimit' => 5,
            'certified' => false,
            'version' => 'v1',
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'cancelAllOrders' => true,                       // DELETE /orders?pair= (pair is optional)
                'cancelOrder' => true,                           // DELETE /orders/by-venue-order-id/:orderId
                'createOrder' => true,                           // POST /orders
                'createStopLimitOrder' => false,
                'createStopMarketOrder' => false,
                'createStopOrder' => false,
                'fetchBalance' => true,                          // GET /customer array(.result.balancesarray())
                'fetchBidsAsks' => true,
                'fetchBorrowRate' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchBorrowRates' => false,
                'fetchBorrowRatesPerSymbol' => false,
                'fetchClosedOrders' => true,                      // GET /orders?status-in=FILLED&pair=XXX (pair is optional, returns max 100 orders)
                'fetchCanceledOrders' => true,                    // GET /orders?status-in=CANCELLED&pair=XXX (pair is optional, returns max 100 orders)
                'fetchCurrencies' => true,                        // GET /assets
                'fetchDepositAddress' => false,
                'fetchDeposits' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,                           // GET /pairs
                'fetchMyTrades' => true,                          // GET /trades?pair=:marketName (pair is optional, returns max 100 results)
                'fetchOHLCV' => false,                            // Currently not supported
                'fetchOpenOrders' => true,                        // GET /orders?status-in=ACTIVE-PARTIALLY_FILLED&pair=XXX (pair is optional, returns max 100 orders)
                'fetchOrder' => true,                             // GET /orders/by-venue-order-id/:orderId
                'fetchOrderBook' => true,                         // GET /pairs/:marketId/orderbook
                'fetchOrders' => true,                            // GET /orders?pair=:marketId (pair is optional, returns max 100 orders)
                'fetchPositionMode' => false,
                'fetchStatus' => false,                           // could maybe use customer endpoint?
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => false,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransactionFees' => false,
                'fetchTransactions' => false,
                'fetchTransfers' => false,
                'fetchWithdrawals' => false,
                'transfer' => false,
                'withdraw' => false,
            ),
            'timeframes' => null,
            'urls' => array(
                'test' => array(
                    'public' => 'https://testnet.api.deepwaters.xyz/rest/v1',
                    'private' => 'https://testnet.api.deepwaters.xyz/rest/v1',
                ),
                'api' => array(
                    'public' => 'https://api.deepwaters.xyz/rest/v1',
                    'private' => 'https://api.deepwaters.xyz/rest/v1',
                ),
                'www' => 'https://deepwaters.xyz',
                'referral' => '',
                'doc' => array(
                    'https://rest.docs.api.deepwaters.xyz/',
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => 0.001,
                    'taker' => 0.0015,
                    // 'feeside' => TODO
                    'feeSide' => 'get',
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'assets',
                        'pairs',
                        'pairs/{pair}/orderbook',
                        'time',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'customer' => 1,
                        'customer/api-key-status' => 1,
                        'orders' => 1,
                        'trades' => 1,
                        'orders/by-venue-order-id/{id}' => 1,
                        'orders/by-customer-object-id/{id}' => 1,
                    ),
                    'post' => array(
                        'orders' => 1,
                    ),
                    'delete' => array(
                        'orders' => 1,
                        'orders/by-venue-order-id/{id}' => 1,
                        'orders/by-customer-object-id/{id}' => 1,
                    ),
                ),
            ),
            'precisionMode' => DECIMAL_PLACES,
        ));
    }

    public function fetch_bids_asks($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches the bid and ask price and volume for multiple markets
             * @param {[string]|null} $symbols unified $symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
             * @param {array} $params extra parameters specific to the deepwaters api endpoint
             * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structures}
             */
            return Async\await($this->fetch_tickers($symbols, $params));
        }) ();
    }

    public function fetch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} $params extra parameters specific to the deepwaters api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
             */
            if (!$symbol) {
                throw new ArgumentsRequired('symbol must be provided to deepwaters#fetchTicket()');
            }
            $tickers = Async\await($this->fetch_tickers(array( $symbol )));
            if (strlen($tickers) === 0) {
                throw new BadSymbol('Symbol not found. Is it available in  deepwaters#fetchMarkets()?');
            }
            return $tickers[$symbol];
        }) ();
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price $tickers for multiple $markets, statistical calculations with the information calculated over the past 24 hours each $market
             * @param {[string]|null} $symbols unified $symbols of the $markets to fetch the ticker for, all $market $tickers are returned if not assigned
             * @param {array} $params extra parameters specific to the deepwaters api endpoint
             * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structures}
             */
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $response = Async\await($this->publicGetPairs ());
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            $markets = $this->safe_value($response, 'result', array());
            $tickers = array();
            for ($i = 0; $i < count($markets); $i++) {
                // {
                //     baseAssetRootSymbol => 'AVAX',
                //     quoteAssetRootSymbol => 'USDC',
                //     baseAssetParentSymbol => 'WAVAX.DW',
                //     quoteAssetParentSymbol => 'USDC.DW',
                //     baseAssetID => 'WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD',
                //     quoteAssetID => 'USDC.AVALANCHE_FUJI.43113.TESTNET.PROD',
                //     name => 'WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD-USDC.AVALANCHE_FUJI.43113.TESTNET.PROD',
                //     baseAssetIncrementSize => '.01',
                //     baseAssetIncrementPrecision => '2',
                //     quoteAssetIncrementSize => '.001',
                //     quoteAssetIncrementPrecision => '3',
                //     createdAtMicros => '1677695274781348',
                //     $quotedAtMicros => '1677838210968536',
                //     $ask => '16.418',
                //     $bid => '16.396'
                // }
                $market = $markets[$i];
                $base = $this->safe_value($market, 'baseAssetRootSymbol');
                $quote = $this->safe_value($market, 'quoteAssetRootSymbol');
                $symbol = $base . '/' . $quote;
                $quotedAtMicros = $this->safe_value($market, 'quotedAtMicros');
                $timestamp = $this->parse_number(Precise::string_div($quotedAtMicros, '1000', 0));
                $datetime = $this->iso8601($timestamp);
                $ask = $this->safe_number($market, 'ask');
                $bid = $this->safe_number($market, 'bid');
                $tickers[] = $this->safe_ticker(array(
                    'symbol' => $symbol,
                    'timestamp' => $timestamp,
                    'datetime' => $datetime,
                    'ask' => $ask,
                    'bid' => $bid,
                    'info' => $market,
                ));
            }
            return $this->filter_by_array($tickers, 'symbol', $symbols);
        }) ();
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all $markets for deepwaters
             * @return {[array]} an array of objects representing $market data
             */
            $response = Async\await($this->publicGetPairs ());
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            // {
            //     "success" => true,
            //     "result" => [
            //       array(
            //         "baseAssetRootSymbol" => "ETH",
            //         "quoteAssetRootSymbol" => "USDC",
            //         "baseAssetParentSymbol" => "WETH.DW",
            //         "quoteAssetParentSymbol" => "USDC.DW",
            //         "baseAssetID" => "WETH_EM_MB",
            //         "quoteAssetID" => "USDC_EM_MB",
            //         "name" => "WETH_EM_MB-USDC_EM_MB",
            //         "baseAssetIncrementSize" => ".00001",
            //         "baseAssetIncrementPrecision" => 5,
            //         "quoteAssetIncrementSize" => ".01",
            //         "quoteAssetIncrementPrecision" => 2,
            //         "createdAtMicros" => 1677434515360241,
            //         "quotedAtMicros" => 1677452326283803,
            //         "ask" => "1636.39",
            //         "bid" => "1631.15"
            //       ),
            //       ...
            $markets = $this->safe_value($response, 'result');
            $result = array();
            for ($i = 0; $i < count($markets); $i++) {
                $market = $markets[$i];
                $id = $this->safe_string($market, 'name');
                $lowercaseId = $this->safe_string_lower($market, 'name');
                $exchangeBaseId = $this->safe_string($market, 'baseAssetID');
                $exchangeQuoteId = $this->safe_string($market, 'quoteAssetID');
                $baseId = $this->safe_string($market, 'baseAssetRootSymbol');
                $quoteId = $this->safe_string($market, 'quoteAssetRootSymbol');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $pricePrecision = $this->safe_string($market, 'quoteAssetIncrementPrecision');
                $amountPrecision = $this->safe_string($market, 'baseAssetIncrementPrecision');
                $entry = array(
                    'id' => $id,
                    'lowercaseId' => $lowercaseId,
                    'symbol' => $base . '/' . $quote,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $exchangeBaseId,
                    'quoteId' => $exchangeQuoteId,
                    'settleId' => null,
                    'type' => 'spot',
                    'spot' => true,
                    'margin' => false,
                    'swap' => false,
                    'future' => false,
                    'option' => false,
                    'active' => true,
                    'contract' => false,
                    'linear' => null,
                    'inverse' => null,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => $this->parse_number($this->parse_precision($amountPrecision)),
                        'price' => $this->parse_number($this->parse_precision($pricePrecision)),
                        // $base and $quote precisions not defined
                        'cost' => null,
                    ),
                    // Docs don't explain what the order limits are
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
                if ($base !== $quote) {
                    // Don't push this $market if $base and $quote are the same
                    // This is currently only true on testnet which has several USDC/USDC $markets
                    $result[] = $entry;
                }
            }
            return $result;
        }) ();
    }

    public function get_nonce() {
        if (!$this->dwnonce) {
            return 0;
        }
        return $this->dwnonce;
    }

    public function fetch_nonce() {
        return Async\async(function ()  {
            $response = Async\await($this->privateGetCustomerApiKeyStatus ());
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            $result = $this->safe_value($response, 'result', array());
            $nonce = $this->safe_string($result, 'nonce', '0');
            $this->dwnonce = $this->parse_number($nonce);
        }) ();
    }

    public function fetch_currencies($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * Fetches all available $currencies an exchange and returns an associative dictionary of $currencies->
             * @param {array} $params extra parameters specific to the deepwaters api endpoint
             * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#$currency-structure $currency structure}
             */
            $response = Async\await($this->publicGetAssets ());
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            // {
            //     "success" => true,
            //     "result" => [
            //       array(
            //         "chainID" => 1,
            //         "chainName" => "ETHEREUM_MAINNET",
            //         "assetAddress" => "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
            //         "rootSymbol" => "USDC",
            //         "assetID" => "USDC_EM_MB",
            //         "parentSymbol" => "USDC.DW",
            //         "frontEndSymbol" => "USDC",
            //         "name" => "USD Coin",
            //         "ticker" => "USDC",
            //         "frontEndName" => "",
            //         "uiDecimals" => 2,
            //         "databaseDecimals" => 25,
            //         "contractDecimals" => 6,
            //         "createdAtMicros" => 1677434515342102
            //       ),
            //       ...
            $currencies = $this->safe_value($response, 'result', array());
            $result = array();
            for ($i = 0; $i < count($currencies); $i++) {
                $currency = $currencies[$i];
                $id = $this->safe_string($currency, 'assetID');
                $code = $this->safe_string($currency, 'rootSymbol');
                $precision = $this->parse_number($this->parse_precision($this->safe_string($currency, 'uiDecimals')));
                // assumes all $currencies are active except those listed above
                $result[$code] = array(
                    'id' => $id,
                    'code' => $code,
                    'info' => $currency,
                    'name' => $code,
                    'active' => true,
                    'deposit' => null,
                    'withdraw' => null,
                    'fee' => null,
                    'precision' => $precision,
                    'limits' => array(
                        'amount' => array(
                            'min' => $precision,
                            'max' => null,
                        ),
                        'withdraw' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                );
            }
            return $result;
        }) ();
    }

    public function parse_balance($response) {
        $timestamp = $this->milliseconds();
        $result = array(
            'info' => $response,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
        $responseResult = $this->safe_value($response, 'result', array());
        $responseBalances = $this->safe_value($responseResult, 'balances', array());
        $balances = $this->is_array($responseBalances) ? $responseBalances : array();
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $currencyId = $this->safe_string($balance, 'assetID');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['total'] = $this->safe_number($balance, 'amount');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'CANCELLED' => 'canceled',
            'REJECTED' => 'rejected',
            'ACTIVE' => 'open',
            'FILLED' => 'closed',
            'PARTIALLY_FILLED' => 'open',
            'EXPIRED' => 'closed',
        );
        return $this->safe_string($statuses, $status, null);
    }

    public function parse_order($order, $market = null) {
        // var_dump('parseorder', $order, $market);
        if ($market === null) {
            $baseId = $this->safe_string($order, 'baseAssetID');
            $base = $this->safe_currency_code($baseId);
            $quoteId = $this->safe_string($order, 'quoteAssetID');
            $quote = $this->safe_currency_code($quoteId);
            if ((!(is_array($this->currencies_by_id) && array_key_exists($quoteId, $this->currencies_by_id))) && (mb_strpos($quoteId, 'USDC') === 0)) {
                // Their testnet has multiple USDC currencies with different IDs.
                // This causes the currencies list USDC entry to be overwritten when currencies
                // are parsed, which means the above will have an null $quote->
                // As of right now, there isn't any ambiguity with mainnet currencies
                $quote = 'USDC';
            }
            $marketSymbol = $base . '/' . $quote;
            $market = $this->market($marketSymbol);
        }
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        // Deepwaters appears to have 2 unique IDs per $order => customerObjectID and
        // venueOrderID. customerObjectID is something the user can set, but is otherwise
        // autogenerated
        $id = $this->safe_string($order, 'venueOrderID');
        $clientOrderId = $this->safe_string($order, 'customerObjectID');
        $createdTimestampMicros = $this->safe_string($order, 'createdAtMicros');
        $updatedTimestampMicros = $this->safe_string($order, 'modifiedAtMicros');
        $createdTimestampMs = null;
        $updatedTimestampMs = null;
        if ($createdTimestampMicros) {
            $createdTimestampMs = Precise::string_div($createdTimestampMicros, '1000', 0);
        }
        if ($updatedTimestampMs) {
            $updatedTimestampMs = Precise::string_div($updatedTimestampMicros, '1000', 0);
        }
        $timeInForce = 'GTC';
        if ($this->safe_string($order, 'durationType') === 'GOOD_TILL_EXPIRY') {
            // GTE doesn't seem to be used anywhere else in ccxt,
            // but deepwaters' api has a distinction
            $timeInForce = 'GTE';
        }
        $type = 'limit';
        if ($this->safe_string($order, 'type') === 'MARKET') {
            $type = 'market';
        }
        $side = 'buy';
        if ($this->safe_string($order, 'side') === 'SELL') {
            $side = 'sell';
        }
        $price = $this->safe_string($order, 'price');
        $remaining = $this->safe_string($order, 'quantity');
        $amount = $this->safe_string($order, 'originalQuantity');
        $filled = Precise::string_sub($amount, $remaining);
        $parsedOrder = array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $this->parse_number($createdTimestampMs),
            'datetime' => $this->iso8601($createdTimestampMs),
            'symbol' => $market['symbol'],
            'type' => $type,
            'timeInForce' => $timeInForce,
            'side' => $side,
            'price' => $this->parse_number($price),
            'amount' => $this->parse_number($amount),
            'filled' => $this->parse_number($filled),
            'remaining' => $this->parse_number($remaining),
            'status' => $status,
            'trades' => null,
            // 'average' => $this->parse_number(average), TODO
            // 'cost' => $this->parse_number(cost), TODO
            'fee' => null, // Not available via API
            'stopPrice' => null, // N/A
            'triggerPrice' => null, // N/A
            'postOnly' => null, // N/A
        );
        if ($status === 'closed') {
            $parsedOrder['lastTradetimestamp'] = $this->parse_number($updatedTimestampMs);
        }
        if (($status === 'open') && ($amount !== $remaining)) {
            $parsedOrder['lastTradeTimestamp'] = $this->parse_number($updatedTimestampMs);
        }
        return $this->safe_order($parsedOrder, $market);
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for $balance and get the $amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the deepwaters api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#$balance-structure $balance structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetCustomer ());
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            // {
            //     customerAddress => '0x4db55abc5e7532439501bc6aed40b6281382959a',
            //     nonce => '1',
            //     createdAtMicros => '1677829125843454',
            //     $modifiedAtMicros => '1677829125843553',
            //     lastCustomerObjectID => null,
            //     $balances => array()
            // }
            $result = $this->safe_value($response, 'result', array());
            $balances = $this->safe_value($result, 'balances');
            $modifiedAtMicros = $this->safe_value($result, 'modifiedAtMicros');
            $timestamp = $this->parse_number(Precise::string_div($modifiedAtMicros, '1000', 0));
            $datetime = $this->iso8601($timestamp);
            $output = array(
                'timestamp' => $timestamp,
                'datetime' => $datetime,
                'info' => $result,
                'free' => array(),
                'used' => array(),
                'total' => array(),
            );
            for ($i = 0; $i < count($balances); $i++) {
                // {
                //     'amount' => 'string',
                //     'assetID' => 'string',
                //     'serviceDescription' => 'string',
                //     'serviceName' => 'string'
                // }
                $balance = $balances[$i];
                $currencyId = $this->safe_value($balance, 'assetID');
                $currency = $this->safe_value($this->currencies_by_id, $currencyId);
                if (!$currency) {
                    // this is only needed in sandbox mode, if you get airdrops
                    continue;
                }
                $currencyCode = $this->safe_value($currency, 'code');
                if (!$output[$currencyCode]) {
                    $output[$currencyCode] = array(
                        'used' => '0',
                        'free' => '0',
                    );
                    $output['used'][$currencyCode] = '0';
                    $output['free'][$currencyCode] = '0';
                }
                $amount = $this->safe_value($balance, 'amount');
                $serviceName = $this->safe_value($balance, 'serviceName');
                if ($serviceName === 'accounting.available') {
                    $output[$currencyCode]['free'] = $amount;
                    $output['free'][$currencyCode] = $amount;
                } elseif ($serviceName === 'fee' || $serviceName === 'swap.engine') {
                    $used = Precise::string_add($output[$currencyCode]['used'], $amount);
                    $output[$currencyCode]['used'] = $used;
                    $output['used'][$currencyCode] = $used;
                }
            }
            $keys = is_array($output['used']) ? array_keys($output['used']) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $key = $keys[$i];
                $total = Precise::string_add($output['used'][$key], $output['free'][$key]);
                $output['total'][$key] = $total;
                $output[$key]['total'] = $total;
            }
            return $this->safe_balance($output);
        }) ();
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the deepwaters api endpoint
             * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'pair' => $market['id'],
            );
            if ($limit !== null) {
                $request['depth'] = $limit;
            }
            $response = Async\await($this->publicGetPairsPairOrderbook (array_merge($request, $params)));
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            $result = $this->safe_value($response, 'result', array());
            //
            // {
            //   snapshotAtMicros => '1641562961192',
            //   asks => array(
            //     array( price => '0.921', quantity => '76.01', depth => 0 ),
            //     array( price => '0.933', quantity => '477.10', depth => 1 ),
            //     ...
            //   ),
            //   bids => array(
            //     array( price => '0.940', quantity => '13502.47', depth => 0 ),
            //     array( price => '0.932', quantity => '43.91', depth => 1 ),
            //     ...
            //   )
            // }
            //
            $timestampMicros = $this->safe_string($result, 'snapshotAtMicros', '0');
            $timestamp = $this->parse_number(Precise::string_div($timestampMicros, '1000', 0));
            return $this->parse_order_book($result, $symbol, $timestamp, 'bids', 'asks', 'price', 'quantity');
        }) ();
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple $orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $request = array();
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['pair'] = $market['id'];
            }
            if ($since !== null) {
                $since = Precise::string_mul($this->decimal_to_precision($since, TRUNCATE, $this->markets[$symbol]['precision']['amount']), '1000');
                $request['created-at-or-after-micros'] = $since;
            }
            if ($limit !== null) {
                $limit = $this->decimal_to_precision($limit, TRUNCATE, $this->markets[$symbol]['precision']['amount']);
                $request['limit'] = $limit;
            }
            $response = Async\await($this->privateGetOrders (array_merge($request, $params)));
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            $result = $this->safe_value($response, 'result', array());
            $orders = $this->safe_value($result, 'orders', array());
            // $success = $this->safe_value($response, 'success', false);
            return $this->parse_orders($orders);
        }) ();
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all $trades made by the user
             * @param {string} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch $trades for
             * @param {int|null} $limit the maximum number of $trades structures to retrieve
             * @param {array} $params extra parameters specific to the deepwaters api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#$trade-structure $trade structures}
             */
            Async\await($this->load_markets());
            $request = array(
                // 'pair' => '',
                // 'type' => '',
                // 'created-at-or-after-micros' => '',
                // 'created-before-micros' => '',
                // 'skip' => '',
                'limit' => 100,
            );
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['pair'] = $market['id'];
            }
            if ($since !== null) {
                $since = Precise::string_mul($this->decimal_to_precision($since, TRUNCATE, $this->markets[$symbol]['precision']['amount']), '1000');
                $request['created-at-or-after-micros'] = $since;
            }
            if ($limit !== null) {
                $limit = $this->decimal_to_precision($limit, TRUNCATE, $this->markets[$symbol]['precision']['amount']);
                $request['limit'] = $limit;
            }
            $type = $this->safe_string($params, 'type');
            if (gettype($type) === 'string') {
                $params = $this->omit($params, 'type');
                if (strtoupper($type) === 'LIMIT') {
                    $request['type'] = 'LIMIT';
                }
                if (strtoupper($type) === 'MARKET') {
                    // Getting the following error right now with $type === 'MARKET' despite what the docs say
                    //     handleRestResponse:
                    //     deepwaters GET https://testnet.api.deepwaters.xyz/rest/v1/trades?$limit=10&pair=WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD-USDC.AVALANCHE_FUJI.43113.TESTNET.PROD&created-at-or-after-micros=1677982036376000&$type=MARKET 400 Bad Request
                    //    ResponseHeaders:
                    //     {
                    //      'Alt-Svc' => 'h3=":443"; ma=2592000',
                    //      Connection => 'close',
                    //      'Content-Length' => '112',
                    //      'Content-Type' => 'application/json; charset=utf-8',
                    //      Date => 'Sun, 05 Mar 2023 05:27:16 GMT',
                    //      Server => 'Caddy',
                    //      Vary => 'Origin'
                    //    }
                    //    ResponseBody:
                    //     array("success":false,"status":"invalid $request","error":"MARKET is an invalid $type-> Valid are => FILL, PARTIAL_FILL")
                    $request['type'] = 'PARTIAL_FILL';
                }
            }
            $response = Async\await($this->privateGetTrades (array_merge($request, $params)));
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            $result = $this->safe_value($response, 'result', array());
            $trades = $this->safe_value($result, 'trades', array());
            $output = array();
            for ($i = 0; $i < count($trades); $i++) {
                // {
                //     "aggressorCustomerObjectID" => "string",
                //     "aggressorFeesTotalValueInQuoteAsset" => "string",
                //     "aggressorFeesQuoteAssetAmount" => "string",
                //     "aggressorFeesWTRAmount" => "string",
                //     "aggressorRemainingQuantity" => "string",
                //     "aggressorVenueOrderID" => "string",
                //     "baseAssetID" => "string",
                //     "createdAtMicros" => 0,
                //     "makerCustomerObjectID" => "string",
                //     "makerFeesTotalValueInQuoteAsset" => "string",
                //     "makerFeesQuoteAssetAmount" => "string",
                //     "makerFeesWTRAmount" => "string",
                //     "makerRemainingQuantity" => "string",
                //     "makerVenueOrderID" => "string",
                //     "makerWasBuyer" => true,
                //     "price" => "string",
                //     "quantity" => "string",
                //     "quoteAssetID" => "string",
                //     "tradeID" => "string",
                //     "tradeType" => "FILL",
                //     "userWasAggressor" => true,
                //     "userWasMaker" => true
                // }
                $trade = $trades[$i];
                $id = $this->safe_value($trade, 'tradeID');
                $createdAtMicros = $this->safe_string($trade, 'createdAtMicros');
                $timestamp = $this->parse_number(Precise::string_div($createdAtMicros, '1000', 0));
                $datetime = $this->iso8601($timestamp);
                $baseAssetID = $this->safe_value($trade, 'baseAssetID');
                $quoteAssetID = $this->safe_value($trade, 'quoteAssetID');
                $market = $this->market($baseAssetID . '-' . $quoteAssetID);
                $symbol = $this->safe_value($market, 'symbol');
                $makerWasBuyer = $this->safe_value($market, 'makerWasBuyer');
                $userWasMaker = $this->safe_value($market, 'userWasMaker');
                $maker = $userWasMaker ? 'maker' : 'taker';
                $orderId = null;
                if ($maker) {
                    $orderId = $this->safe_string($trade, 'makerVenueOrderID');
                } else {
                    $orderId = $this->safe_string($trade, 'aggressorVenueOrderID');
                }
                $side = $userWasMaker === $makerWasBuyer ? 'buy' : 'sell';
                $price = $this->safe_number($trade, 'price');
                $amount = $this->safe_number($trade, 'quantity');
                $cost = Precise::string_mul($this->safe_string($trade, 'price'), $this->safe_string($trade, 'quantity'));
                $userWasAggressor = $this->safe_value($market, 'userWasAggressor');
                $type = $userWasAggressor ? 'market' : 'limit';
                $output[] = $this->safe_trade(array(
                    'info' => $trade,
                    'id' => $id,
                    'timestamp' => $timestamp,
                    'datetime' => $datetime,
                    'symbol' => $symbol,
                    'order' => $orderId,
                    'type' => $type,
                    'side' => $side,
                    'takerOrMaker' => $maker,
                    'price' => $price,
                    'amount' => $amount,
                    'cost' => $cost,
                ));
            }
            return $output;
        }) ();
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $suppliedFilters = $this->safe_string($params, 'status-in', explode('-', ''));
        $constructedFilters = array( 'ACTIVE', 'PARTIALLY_FILLED' );
        $remainingAvailableFilters = array( 'FILLED', 'REJECTED', 'CANCELLED', 'EXPIRED' );
        for ($i = 0; $i < count($remainingAvailableFilters); $i++) {
            $filter = $remainingAvailableFilters[$i];
            if ($this->in_array($filter, $suppliedFilters)) {
                $constructedFilters[] = $filter;
            }
        }
        $params = array_merge($params, array( 'status-in' => implode('-', $constructedFilters) ));
        // var_dump($symbol, $since, $limit, $params);
        return $this->fetch_orders($symbol, $since, $limit, $params);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $suppliedFilters = $this->safe_string($params, 'status-in', explode('-', ''));
        $constructedFilters = array( 'FILLED' );
        $remainingAvailableFilters = array( 'ACTIVE', 'REJECTED', 'CANCELLED', 'EXPIRED', 'PARTIALLY_FILLED' );
        for ($i = 0; $i < count($remainingAvailableFilters); $i++) {
            $filter = $remainingAvailableFilters[$i];
            if ($this->in_array($filter, $suppliedFilters)) {
                $constructedFilters[] = $filter;
            }
        }
        $params = array_merge($params, array( 'status-in' => implode('-', $constructedFilters) ));
        return $this->fetch_orders($symbol, $since, $limit, $params);
    }

    public function fetch_canceled_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $suppliedFilters = $this->safe_string($params, 'status-in', explode('-', ''));
        $constructedFilters = array( 'CANCELLED' );
        $remainingAvailableFilters = array( 'ACTIVE', 'REJECTED', 'CANCELLED', 'EXPIRED', 'PARTIALLY_FILLED' );
        for ($i = 0; $i < count($remainingAvailableFilters); $i++) {
            $filter = $remainingAvailableFilters[$i];
            if ($this->in_array($filter, $suppliedFilters)) {
                $constructedFilters[] = $filter;
            }
        }
        $params = array_merge($params, array( 'status-in' => implode('-', $constructedFilters) ));
        return $this->fetch_orders($symbol, $since, $limit, $params);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create an $order
             * @param {string} $symbol unified $symbol of the $market to create an $order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float|null} $price the $price at which the $order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} $params extra parameters specific to the deepwaters api endpoint
             * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#$order-structure $order structure}
             */
            Async\await($this->load_markets());
            $durationType = $this->safe_string($params, 'durationType', 'GOOD_TILL_CANCEL');
            $orderType = strtoupper($type);
            $market = $this->market($symbol);
            $orderSide = strtoupper($side);
            $customerObjectId = $this->safe_string($params, 'customerObjectId');
            $expiresAtMicros = $this->safe_number($params, 'expiresAtMicros', 0);
            $expiresIn = $this->safe_value($params, 'expiresIn', '');
            $precisionQuantity = $this->amount_to_precision($symbol, $amount);
            // {
            //     "baseAssetID" => "string",
            //     "customerObjectID" => "string",
            //     "durationType" => "GOOD_TILL_CANCEL",
            //     "expiresAtMicros" => 0,
            //     "expiresIn" => "string",
            //     "price" => "string",
            //     "quantity" => "string",
            //     "quoteAssetID" => "string",
            //     "side" => "BUY",
            //     "type" => "LIMIT"
            //   }
            $request = array(
                'baseAssetID' => $market['baseId'],
                'durationType' => $durationType,
                'customerObjectID' => $customerObjectId,
                'type' => $orderType,
                'side' => $orderSide,
                'quoteAssetID' => $market['quoteId'],
                'quantity' => $precisionQuantity,
            );
            if ($type === 'limit') {
                $precisionPrice = $this->price_to_precision($symbol, $price);
                $request['price'] = $precisionPrice;
                if ($durationType === 'GOOD_TILL_EXPIRY') {
                    $request['expiresIn'] = $expiresIn ? $expiresIn : null;
                    $request['expiresAtMicros'] = $expiresAtMicros ? $expiresAtMicros : null;
                }
            }
            Async\await($this->fetch_nonce());
            $response = Async\await($this->privatePostOrders ($request));
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            // Market Order
            // {
            //     $status => 'FILLED',
            //     $respondedAtMicros => '1677872186295635',
            //     venueOrderID => '0x85b3e1dd0c9f4609a3b611f991c54c51d85ab510745b11a039af52c0bab46b1a',
            //     $originalQuantity => '1.00',
            //     quantity => '0.00'
            // }
            // Limit Order
            $result = $this->safe_value($response, 'result', array());
            $id = $this->safe_string($result, 'venueOrderID');
            $respondedAtMicros = $this->safe_string($result, 'respondedAtMicros');
            $timestamp = $this->parse_number(Precise::string_div($respondedAtMicros, '1000', 0));
            $datetime = $this->iso8601($timestamp);
            $exchangeStatus = $this->safe_value($result, 'status');
            $status = $this->parse_order_status($exchangeStatus);
            $originalQuantity = $this->safe_string($result, 'originalQuantity');
            $order = array(
                'id' => $id,
                'timestamp' => $timestamp,
                'datetime' => $datetime,
                'status' => $status,
                'symbol' => $symbol,
                'type' => $type,
                'side' => $side,
                'amount' => $originalQuantity,
                'info' => $result,
            );
            if ($exchangeStatus === 'FILLED') {
                $order['filled'] = $originalQuantity;
            }
            if ($type === 'limit') {
                $order['price'] = $price;
            }
            return $this->safe_order($order);
        }) ();
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            // $params and $symbol are unused
            Async\await($this->load_markets());
            $params = array(
                'id' => $id,
            );
            if (gettype($id) !== 'string') {
                throw new ArgumentsRequired($this->id . ' cancelOrder () requires a string id');
            }
            $isVenueId = mb_substr($id, 0, 2 - 0) === '0x';
            $response = null;
            if ($isVenueId) {
                $response = Async\await($this->privateGetOrdersByVenueOrderIdId ($params));
            } else {
                $response = Async\await($this->privateGetOrdersByCustomerObjectIdId ($params));
            }
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            $result = $this->safe_value($response, 'result', array());
            return $this->parse_order($result);
        }) ();
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open $order
             * @param {string} $id $order $id
             * @param {string} $symbol unused
             * @param {array} $params unused
             * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#$order-structure $order structure}
             */
            Async\await($this->load_markets());
            Async\await($this->fetch_nonce());
            $params = array(
                'id' => $id,
            );
            if (gettype($id) !== 'string') {
                throw new ArgumentsRequired($this->id . ' cancelOrder () requires a string id');
            }
            $isVenueId = mb_substr($id, 0, 2 - 0) === '0x';
            $response = null;
            if ($isVenueId) {
                $response = Async\await($this->privateDeleteOrdersByVenueOrderIdId ($params));
            } else {
                $response = Async\await($this->privateDeleteOrdersByCustomerObjectIdId ($params));
            }
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            // Deepwaters doesn't respond with any $order information on cancelation
            $result = $this->safe_value($response, 'result');
            $respondedAtMicros = $this->safe_value($result, 'respondedAtMicros');
            $timestamp = $this->parse_number(Precise::string_div($respondedAtMicros, '1000', 0));
            $datetime = $this->iso8601($timestamp);
            $order = array(
                'status' => 'canceled',
                'id' => $id,
                'datetime' => $datetime,
                'timestamp' => $timestamp,
                'symbol' => $symbol,
                'info' => $result,
            );
            return $this->safe_order($order);
        }) ();
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            Async\await($this->load_markets());
            Async\await($this->fetch_nonce());
            if ($symbol) {
                $market = $this->market($symbol);
                $pairParam = array(
                    'pair' => $market->id,
                );
                $params = array_merge($params, $pairParam);
            }
            $response = Async\await($this->privateDeleteOrders ($params));
            // EXAMPLE $response
            // {
            //     "result" => array(
            //       "numCancelled" => 0,
            //       "respondedAtMicros" => 0
            //     ),
            //     "success" => true
            //   }
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            return $this->safe_value($response, 'result', array());
        }) ();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        /**
         * Signs an $api request to deepwaters exchange
         * @see https://rest.docs.api.deepwaters.xyz/cutting_edge/index.html
        */
        // Get array of $params which need to be substituted in $path
        $pathParams = $this->extract_params($path);
        // this is the $path with any variable segments substituted from provided $params
        // currently only relevant for 'pairs/{marketId}/orderbook', which isn't signed
        $path = '/' . $this->implode_params($path, $params);
        // Remove $params which were substituted in $path, important for signing
        $params = $this->omit($params, $pathParams);
        $nonce = '';
        $bodyString = '';
        if ($api === 'private') {
            $headers = array();
            $timestamp = $this->number_to_string($this->microseconds() + 10);
            $this->check_required_credentials();
            if (($method === 'GET') || ($method === 'DELETE')) {
                $keys = is_array($params) ? array_keys($params) : array();
                if (strlen($keys)) {
                    $path = $path . '?' . $this->urlencode($params);
                }
            }
            if (($method === 'POST') || ($method === 'DELETE')) {
                if ($method === 'POST') {
                    $body = $params;
                    $bodyString = json_encode ($body);
                }
                $nonce = $this->number_to_string($this->get_nonce());
                $postDeleteHeaders = array(
                    'content-type' => 'application/json',
                    'X-DW-NONCE' => $nonce,
                );
                $headers = array_merge($headers, $postDeleteHeaders);
            }
            $message = $method . '/rest/v1' . strtolower($path) . $timestamp . $nonce . $bodyString;
            // calculate $signature
            $signature = $this->sign_hash($this->hash($message, 'keccak'), $this->secret);
            $signature->v = $signature->v - 27;
            $vByte = $signature->v.toString (16);
            if (strlen($vByte) === 1) {
                $vByte = '0' . $vByte;
            }
            $signatureString = $signature->r . mb_substr($signature->s, 2) . $vByte;
            $sigHeaders = array(
                'X-DW-APIKEY' => $this->apiKey,
                'X-DW-TSUS' => $timestamp,
                'X-DW-SIGHEX' => $signatureString,
            );
            $headers = array_merge($headers, $sigHeaders);
        }
        $url = $this->urls['api'][$api] . $path;
        if (strlen($bodyString)) {
            return array( 'url' => $url, 'method' => $method, 'body' => $bodyString, 'headers' => $headers );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_error($response = array ()) {
        $error = $this->safe_string($response, 'error', '');
        $code = $this->safe_string($response, 'code', '');
        $status = $this->safe_string($response, 'status', '');
        throw new ExchangeError($code . ' => ' . $error . ' ' . $status);
    }

    public function fetch_time($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * fetches the current integer $timestamp in milliseconds from the deepwaters server
             * @param {array} $params extra parameters specific to the deepwaters api endpoint
             * @return {int} the current integer $timestamp in milliseconds from the deepwaters server
             */
            $response = Async\await($this->publicGetTime ());
            $success = $this->safe_value($response, 'success', false);
            if (!$success) {
                throw $this->handle_error($response);
            }
            $timestampMicros = $this->safe_value($response, 'timestampMicros');
            $timestamp = $this->parse_number(Precise::string_div($timestampMicros, '1000', 0));
            return $timestamp;
        }) ();
    }

    public function sign_hash($hash, $privateKey) {
        $signature = $this->ecdsa(mb_substr($hash, -64), mb_substr($privateKey, -64), 'secp256k1', null);
        return array(
            'r' => '0x' . $signature['r'],
            's' => '0x' . $signature['s'],
            'v' => 27 . $signature['v'],
        );
    }
}
