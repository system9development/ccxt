<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\coinstore as Exchange;
use ccxt\BadRequest;
use ccxt\Precise;
use React\Async;

class coinstore extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'coinstore',
            'name' => 'Coinstore',
            'countries' => array( 'SG' ),
            'rateLimit' => 1000,
            'version' => 'v1',
            'certified' => false,
            'pro' => false,
            'has' => array(
                'CORS' => true,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => 'emulated',
                'fetchCurrencies' => false,
                'fetchDeposits' => false,
                'fetchDepositWithdrawFee' => false,
                'fetchDepositWithdrawFees' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchLeverage' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => false,
                'fetchOpenInterest' => false,
                'fetchOpenOrders' => 'emulated',
                'fetchOrder' => false,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchPositions' => false,
                'fetchTicker' => false,
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTransfers' => false,
                'fetchWithdrawals' => false,
                'setLeverage' => false,
                'setMargin' => false,
                'setMarginMode' => false,
                'transfer' => false,
            ),
            'hostname' => 'coinstore.com',
            'urls' => array(
                'logo' => 'https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/253675376-6983b72e-4999-4549-b177-33b374c195e3.jpg',
                'api' => array(
                    'spot' => 'https://api.{hostname}',
                ),
                'www' => 'https://www.coinstore.com/',
                'doc' => 'https://coinstore-openapi.github.io/en/',
                'referral' => null,
                'fees' => 'https://www.coinstore.com/#/fee',
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        // Get all tickers
                        'api/v1/market/tickers' => 3,
                        // Get public trades
                        'api/v1/market/trade/{symbol}' => 3,
                        // Get orderbook
                        'api/v1/market/depth/{symbol}' => 3,
                    ),
                    'post' => array(
                        // fetch markets
                        'v2/public/config/spot/symbols' => 3,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        // Get open orders
                        'api/v2/trade/order/active' => 3,
                        // Fetch all orders
                        'api/trade/order/historyOrders' => 3,
                        // Get an individual order
                        'api/v2/trade/order/orderInfo' => 3,
                        // fetch user trades
                        'api/trade/match/accountMatches' => 3,
                    ),
                    'post' => array(
                        // get balances
                        'api/spot/accountList' => 3,
                        // create order
                        'api/trade/order/place' => 3,
                        // cancel order
                        'api/trade/order/cancel' => 3,
                        // cancel all orders
                        'api/trade/order/cancelAll' => 3,
                    ),
                ),
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
                '3d' => '3d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'fees' => array(
                'trading' => array(),
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(
                    // may be used when a param is missing
                    '400' => '\\ccxt\\BadRequest',
                    '401' => '\\ccxt\\AuthenticationError',
                    '403' => '\\ccxt\\PermissionDenied',
                    '404' => '\\ccxt\\BadRequest',
                    '429' => '\\ccxt\\DDoSProtection',
                    '500' => '\\ccxt\\ExchangeError',
                    '1101' => '\\ccxt\\InsufficientFunds',
                    '10001' => '\\ccxt\\ExchangeError',
                ),
                'broad' => array(),
            ),
            'commonCurrencies' => array(),
        ));
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * Uses tickers endpoint since coinstore doesn't have a $market $data endpoint:
             * https://api.coinstore.com/api/v2/public/config/spot/symbols
             *
             * retrieves $data on spot markets for coinstore
             * @see https://coinstore-openapi.github.io/en/#ticker-related
             * @param {array} [$params] extra parameters specific to the exchange api endpoint
             * @return {[array]} an array of objects representing $market $data
             */
            $response = Async\await($this->publicPostV2PublicConfigSpotSymbols ());
            $data = $this->safe_value($response, 'data');
            $result = array();
            // {
            //     "code" => "0",
            //     "message" => "Success",
            //     "data" => array(
            //         {
            //             "symbolId" => 1,
            //             "symbolCode" => "BTCUSDT",
            //             "tradeCurrencyCode" => "btc",
            //             "quoteCurrencyCode" => "usdt",
            //             "openTrade" => true,
            //             "onLineTime" => 1609813531019,
            //             "tickSz" => 0,
            //             "lotSz" => 4,
            //             "minLmtPr" => "0.0002",
            //             "minLmtSz" => "0.2",
            //             "minMktVa" => "0.1",
            //             "minMktSz" => "0.1",
            //             "makerFee" => "0.006",
            //             "takerFee" => "0.003"
            //         }
            //     )
            // }
            for ($i = 0; $i < count($data); $i++) {
                $market = $data[$i];
                // different endpoints use different case for market/currency IDs
                // lowercase everything to be safe
                $id = $this->safe_string_lower($market, 'symbolCode');
                $baseId = $this->safe_string_lower($market, 'tradeCurrencyCode');
                $quoteId = $this->safe_string_lower($market, 'quoteCurrencyCode');
                $base = $this->safe_currency_code($baseId);
                $quote = $this->safe_currency_code($quoteId);
                $symbol = $base . '/' . $quote;
                // $symbolId = $this->safe_string($market, 'symbolId');
                // if (!(is_array(coinstoreMarketsByNumericId) && array_key_exists($symbolId, coinstoreMarketsByNumericId))) {
                //     coinstoreMarketsByNumericId[$symbolId] = $symbol;
                // }
                $lowercaseId = $id;
                $active = $this->safe_value($market, 'openTrade');
                $pricePrecision = $this->safe_number($market, 'tickSz');
                $amountPrecision = $this->safe_number($market, 'lotSz');
                $minSize = $this->safe_number($market, 'minLmtSz');
                $minPrice = $this->safe_number($market, 'minLmtPr');
                $entry = array(
                    'id' => $id,
                    'lowercaseId' => $lowercaseId,
                    'symbol' => $symbol,
                    'base' => $base,
                    'quote' => $quote,
                    'settle' => null,
                    'baseId' => $baseId,
                    'quoteId' => $quoteId,
                    'settleId' => null,
                    'type' => 'spot',
                    'spot' => true,
                    'margin' => false,
                    'swap' => false,
                    'future' => false,
                    'delivery' => false,
                    'option' => false,
                    'active' => $active !== false,
                    'contract' => false,
                    'linear' => null,
                    'inverse' => null,
                    'contractSize' => null,
                    'expiry' => null,
                    'expiryDatetime' => null,
                    'strike' => null,
                    'optionType' => null,
                    'precision' => array(
                        'amount' => (string) $this->parse_number($this->parse_precision($amountPrecision)),
                        'price' => (string) $this->parse_number($this->parse_precision($pricePrecision)),
                        'base' => null,
                        'quote' => null,
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => null,
                        ),
                        'amount' => array(
                            'min' => $minSize,
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => $minPrice,
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                    'info' => $market,
                );
                $result[] = $entry;
            }
            return $result;
        }) ();
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @see https://coinstore-openapi.github.io/en/#get-user-39-s-latest-trade
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {number} [$since] timestamp used to filter out older $trades
             * @param {number} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params=array()] extra parameters specific to the coinstore api endpoint
             * @param {string} [$params->ordId] the order to get $trades for
             * @param {number} [$params->pageNum] which page of $trades to list
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            $this->check_required_symbol('fetchTrades', $symbol);
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['size'] = $limit;
            }
            $response = Async\await($this->publicGetApiV1MarketTradeSymbol (array_merge($request, $params)));
            $trades = $this->safe_value($response, 'data', array());
            return $this->parse_trades($trades, $market, $since);
        }) ();
    }

    public function parse_public_trade($trade, $market = null) {
        // public trades:
        // {
        //     "channel" => "4@$trade",
        //     "time" => 1642495112,
        //     "volume" => "0.011102",
        //     "price" => "41732.3305",
        //     "tradeId" => 14867136,
        //     "takerSide" => "BUY",
        //     "seq" => 14867136,
        //     "ts" => 1642495112000,
        //     "symbol" => "BTCUSDT",
        //     "instrumentId" => 4
        // }
        $timestamp = $this->safe_number($trade, 'ts');
        $symbol = $market['symbol'];
        $price = $this->parse_number($this->safe_string($trade, 'price'));
        $amount = $this->parse_number($this->safe_string($trade, 'volume'));
        $cost = null;
        if ($price && $amount) {
            $cost = $price * $amount;
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'tradeId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => null,
            'type' => null,
            'side' => $this->safe_string($trade, 'takerSide') === 'BUY' ? 'sell' : 'buy',
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => null,
        ), $market);
    }

    public function parse_private_trade($trade, $market = null) {
        // user trades:
        // {
        //     "id" => 3984987,
        //     "remainingQty" => 0E-18,
        //     "matchRole" => 1,
        //     "feeCurrencyId" => 44,
        //     "acturalFeeRate" => 0.002000000000000000,
        //     "role" => 1,
        //     "accountId" => 1138204,
        //     "instrumentId" => 15,
        //     "baseCurrencyId" => 44,
        //     "quoteCurrencyId" => 30,
        //     "execQty" => 40.900000000000000000,
        //     "orderState" => 50,
        //     "matchId" => 258338866,
        //     "orderId" => 1717384395096065,
        //     "side" => 1,
        //     "execAmt" => 8.887161000000000000,
        //     "selfDealingQty" => 0E-18,
        //     "tradeId" => 11523732,
        //     "fee" => 0.081800000000000000,
        //     "matchTime" => 1637825389,
        //     "seq" => null
        // }
        $timestamp = $this->safe_number($trade, 'matchTime', 0) * 1000;
        // Docs claim this is a string 'TAKER' or 'MAKER', but example shows 1
        $role = $this->safe_string_lower($trade, 'role');
        $takerOrMaker = 'maker';
        if ($role === '1' || $role === 'taker') {
            $takerOrMaker = 'taker';
        }
        // $numericId = $this->safe_string($trade, 'instrumentId');
        // $symbol = $this->safe_string(coinstoreMarketsByNumericId, $numericId);
        $symbol = $market['symbol'];
        $feeCurrencyId = $this->safe_number($trade, 'feeCurrencyId');
        $baseCurrencyId = $this->safe_number($trade, 'baseCurrencyId');
        $rate = $this->safe_number($trade, 'acturalFeeRate');
        $fee = $this->safe_number($trade, 'fee');
        $feeCurrency = $feeCurrencyId === $baseCurrencyId ? $market['base'] : $market['quote'];
        $cost = $this->safe_string($trade, 'execAmt');
        $amount = $this->safe_string($trade, 'execQty');
        $price = Precise::string_div($cost, $amount);
        $order = $this->safe_string($trade, 'orderId');
        $side = null;
        if ($this->safe_number($trade, 'side') === 1) {
            $side = 'buy';
        }
        if ($this->safe_number($trade, 'side') === -1) {
            $side = 'sell';
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $order,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $this->parse_number($price),
            'amount' => $this->parse_number($amount),
            'cost' => $this->parse_number($cost),
            'fee' => array(
                'cost' => $fee,
                'currency' => $feeCurrency,
                'rate' => $rate,
            ),
        ), $market);
    }

    public function parse_trade($trade, $market = null) {
        if ($this->safe_string($trade, 'channel')) {
            return $this->parse_public_trade($trade, $market);
        }
        return $this->parse_private_trade($trade, $market);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @see https://coinstore-openapi.github.io/en/index.html#get-depth
             * @param {string} $symbol unified $symbol of the $market to fetch the order book for
             * @param {number} [$limit] the maximum amount of order book entries to return
             * @param {array} [$params] extra parameters specific to the coinstore api endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
             */
            $this->check_required_symbol('fetchOrderBook', $symbol);
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['depth'] = $limit;
            }
            $response = Async\await($this->publicGetApiV1MarketDepthSymbol (array_merge($request, $params)));
            $orderbook = $this->safe_value($response, 'data', array());
            return $this->parse_order_book($orderbook, $symbol, Date.now (), 'b', 'a', 0, 1);
        }) ();
    }

    public function fetch_ticker($symbol, $params = array ()) {
        /**
         * fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
         * @see https://coinstore-openapi.github.io/en/#ticker-related
         * @param {string} $symbol unified $symbol of the market to fetch the ticker for
         * @param {array} [$params] extra parameters specific to the coinstore api endpoint
         * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
         */
        return $this->fetch_tickers(array( $symbol ), $params);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price $tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
             * @see https://coinstore-openapi.github.io/en/index.html#ticker
             * @param {[string]|null} $symbols unified $symbols of the markets to fetch the ticker for, all market $tickers are returned if not assigned
             * @param {array} [$params] extra parameters specific to the coinstore api endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structures~
             */
            Async\await($this->load_markets());
            $ids = is_array($this->markets_by_id) ? array_keys($this->markets_by_id) : array();
            for ($i = 0; $i < count($ids); $i++) {
                $ids[$i] = strtoupper($ids[$i]);
            }
            $response = Async\await($this->publicGetApiV1MarketTickers ($params));
            // We need to filter out $tickers for markets that are not in the market list (coinstore doesn't return all markets in the market info endpoint)
            $tickers = $this->filter_by_array($this->safe_value($response, 'data'), 'symbol', $ids);
            return $this->parse_tickers($tickers, $symbols);
        }) ();
    }

    public function parse_ticker($ticker, $market = null) {
        // {
        //     "channel" => "ticker",
        //     "bidSize" => "454.2",
        //     "askSize" => "542.6",
        //     "count" => 41723,
        //     "volume" => "24121351.85",
        //     "amount" => "1693799.10798965",
        //     "close" => "0.067998",
        //     "open" => "0.071842",
        //     "high" => "0.072453",
        //     "low" => "0.067985",
        //     "bid" => "0.0679",
        //     "ask" => "0.0681",
        //     "symbol" => "TRXUSDT",
        //     "instrumentId" => 2
        // }
        $marketId = $this->safe_string_lower($ticker, 'symbol');
        $market = $this->market($marketId);
        $open = $this->safe_number($ticker, 'open');
        $high = $this->safe_number($ticker, 'high');
        $low = $this->safe_number($ticker, 'low');
        $close = $this->safe_number($ticker, 'close');
        $last = $close;
        $quoteVolume = $this->safe_number($ticker, 'volume');
        $baseVolume = $this->safe_number($ticker, 'amount');
        $bid = $this->safe_number($ticker, 'bid');
        $ask = $this->safe_number($ticker, 'ask');
        $change = $open - $close;
        $vwap = $quoteVolume / $baseVolume;
        $average = ($open . $close) / 2;
        $percentage = ($change / $open) * 100;
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => null,
            'datetime' => null,
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => null,
            'ask' => $ask,
            'askVolume' => null,
            'vwap' => $vwap,
            'open' => $open,
            'close' => $close,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => $average,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @see https://coinstore-openapi.github.io/en/#assets-balance
             * @param {array} [$params] extra parameters specific to the conistore api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privatePostApiSpotAccountList ());
            return $this->parse_balance($response);
        }) ();
    }

    public function parse_balance($response) {
        $balances = $this->safe_value($response, 'data', array());
        $result = array( 'info' => $response );
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $type = $this->safe_number($balance, 'type');
            $currencyId = $this->safe_string_lower($balance, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->safe_value($result, $code, $this->account());
            if ($type === 1) {
                // this is the 'available' $balance
                $account['free'] = $this->safe_number($balance, 'balance', 0);
                $account['used'] = $this->safe_number($account, 'used', 0);
            } elseif ($type === 4) {
                $account['used'] = $this->safe_number($balance, 'balance', 0);
                $account['free'] = $this->safe_number($account, 'free', 0);
            }
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade order
             * @see https://coinstore-openapi.github.io/en/#create-order
             * @param {string} $symbol unified $symbol of the market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {number} $amount how much of currency you want to trade in units of base currency
             * @param {number} [$price] the $price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
             * @param {array} [$params] extra parameters specific to the coinstore api endpoint
             * @param {string} [$params->clOrdId] a custom order ID
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            $this->check_required_symbol('createOrder', $symbol);
            Async\await($this->load_markets());
            $request = array(
                'symbol' => $this->market_id($symbol),
                'ordType' => strtoupper($type),
                'side' => strtoupper($side),
            );
            if ($request['ordType'] === 'LIMIT') {
                $request['ordPrice'] = $this->price_to_precision($symbol, $price);
            }
            if ($request['ordType'] === 'MARKET' && strtolower($side) === 'buy') {
                $ordAmt = $this->safe_number($params, 'ordAmt');
                if ($amount !== null) {
                    throw new BadRequest($this->id . ' createOrder () does not support the $amount parameter for market buy orders, for the $amount of quote currency to spend use the $ordAmt parameter');
                }
                if (!$ordAmt) {
                    throw new BadRequest($this->id . ' createOrder () requires an $ordAmt parameter for market buy orders, for the $amount of quote currency to spend');
                }
                $request['ordAmt'] = $this->price_to_precision($symbol, $ordAmt);
            } else {
                $request['ordQty'] = $this->amount_to_precision($symbol, $amount);
            }
            $request['timestamp'] = $this->milliseconds();
            $response = Async\await($this->privatePostApiTradeOrderPlace (array_merge($request, $params)));
            $responseData = $this->safe_value($response, 'data', array());
            return $this->parse_submitted_order($request, $responseData);
        }) ();
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             * @see https://coinstore-openapi.github.io/en/index.html#cancel-orders
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the $market the order was made in
             * @param {array} [$params] extra parameters specific to the coinstore api endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            $this->check_required_argument('cancelOrder', $symbol, 'symbol');
            $this->check_required_argument('cancelOrder', $id, 'id');
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
                'ordId' => $id,
            );
            $response = Async\await($this->privatePostApiTradeOrderCancel (array_merge($request, $params)));
            return $this->parse_canceled_order($request, $response);
        }) ();
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders
             * @see https://coinstore-openapi.github.io/en/index.html#one-click-cancellation
             * @param {string|null} [$symbol] unified $market $symbol, only orders in the $market of this $symbol are cancelled when $symbol is not null
             * @param {array} [$params] extra parameters specific to the coinstore api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $request = array();
            if ($symbol) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            // The response for this endpoint is empty, so to return the correct information we should use the fetchOrders endpoint
            $cancelResponse = Async\await($this->privatePostApiTradeOrderCancelAll (array_merge($request, $params)));
            $canceledOrderIds = $this->safe_value($this->safe_value($cancelResponse, 'data', array()), 'canceling', array());
            // Stringify these ids
            for ($i = 0; $i < count($canceledOrderIds); $i++) {
                $canceledOrderIds[$i] = (string) $canceledOrderIds[$i];
            }
            $endTimestamp = Date.now ();
            try {
                $orderResponse = Async\await($this->fetch_orders($symbol, null, null, array( 'endTime' => $endTimestamp, 'ordType' => 'LIMIT' )));
                return is_array($this->filter_by_array($orderResponse, 'id', $canceledOrderIds)) ? array_values($this->filter_by_array($orderResponse, 'id', $canceledOrderIds)) : array();
            } catch (Exception $e) {
                // return an empty array; the fetchOrders call failed, but cancelation succeeded
                return array();
            }
        }) ();
    }

    public function parse_canceled_order($request, $response) {
        // $request:
        // {
        //    "symbol" => "btcusdt",
        //    "ordId" => 1722183748419690
        // }
        //
        // $response:
        // {
        //     "code" => 0,
        //     "data" => {
        //         "clientOrderId" => "b1b2ea5e00a84b888d419cb73f8eb203",
        //         "state" => "CANCELED",
        //         "ordId" => 1722183748419690
        //     }
        // }
        $data = $this->safe_value($response, 'data');
        $orderId = $this->safe_value($data, 'ordId');
        $symbol = $this->safe_string($request, 'symbol');
        $market = $this->market($symbol);
        $info = array_merge(array( 'request' => $request ), array( 'response' => $response ));
        return $this->safe_order(array(
            'info' => $info,
            'id' => $orderId,
            'symbol' => $symbol,
            'status' => 'canceled',
        ), $market);
    }

    public function parse_submitted_order($request, $response) {
        // $response (docs are wrong):
        // {
        //     "code" => "0",
        //     "data" => {
        //         "ordId" => 11594964764657880
        //     }
        // }
        $orderId = $this->safe_number($response, 'ordId');
        $info = array_merge(array( 'request' => $request ), array( 'response' => $response ));
        $marketId = $this->safe_string_lower($request, 'symbol');
        $market = $this->market($marketId);
        $symbol = $market['symbol'];
        $side = $this->safe_string_lower($request, 'side');
        $type = $this->safe_string_lower($request, 'ordType');
        $price = $this->safe_number($request, 'ordPrice');
        $amount = $this->safe_number($request, 'ordQty');
        return $this->safe_order(array(
            'info' => $info,
            'id' => $orderId,
            'symbol' => $symbol,
            'side' => $side,
            'type' => $type,
            'price' => $price,
            'amount' => $amount,
        ), $market);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://coinstore-openapi.github.io/en/#get-current-$orders-v2
             * fetch all open $orders orders
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} [$since] the earliest time in ms to fetch open $orders for
             * @param {int} [$limit] the maximum number of open order structures to retrieve
             * @param {array} [$params] extra parameters specific to the coinstore api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            if ($limit !== null) {
                // set to max, because we use this for fetchClosedOrders, but there's no status filter
                $request['size'] = 100;
            }
            if ($since !== null) {
                $request['startTime'] = $since;
            }
            $response = Async\await($this->privateGetApiTradeOrderHistoryOrders (array_merge($request, $params)));
            $data = $this->safe_value($response, 'data');
            $orders = $this->safe_value($data, 'list', array());
            return $this->parse_orders($orders, $market, $since, $limit);
        }) ();
    }

    public function parse_order($order, $market = null) {
        // history response format:
        // array(
        //     "baseCurrency" => "USDC",
        //     "quoteCurrency" => "USDT",
        //     "side" => "SELL",
        //     "cumQty" => "22",
        //     "ordId" => 1773897094529949,
        //     "clOrdId" => "0",
        //     "ordType" => "LIMIT",
        //     "ordQty" => "98.48",
        //     "cumAmt" => "21.7752",
        //     "timeInForce" => "GTC",
        //     "ordPrice" => "0.9896",
        //     "leavesQty" => "0",
        //     "avgPrice" => "0.9898",
        //     "ordState" => "CANCELED",
        //     "symbol" => "USDCUSDT",
        //     "timestamp" => 1691720096406,
        //     "accountId" => 3643140,
        //     "feeCurrency" => "USDT",
        //     "ordAmt" => "97.455808"
        // ),
        // active response format:
        // {
        //     "baseCurrency" => "A123",
        //     "quoteCurrency" => "USDT",
        //     "side" => "BUY",
        //     "cumQty" => "0",
        //     "ordId" => 1758065956225025,
        //     "clOrdId" => "tLCGVA4g19zuEBwsITXi9g3U624Al0Bw",
        //     "ordType" => "LIMIT",
        //     "ordQty" => "10",
        //     "cumAmt" => "0",
        //     "accountId" => 1134912,
        //     "timeInForce" => "GTC",
        //     "ordPrice" => "100",
        //     "leavesQty" => "10",
        //     "avgPrice" => "0",
        //     "ordStatus" => "SUBMITTED",
        //     "symbol" => "A123USDT",
        //     "timestamp" => 1676622290389
        // }
        $timestamp = $this->safe_number($order, 'timestamp');
        $feeCurrency = $this->safe_string($order, 'feeCurrency');
        $fee = null;
        if ($feeCurrency) {
            $fee = array(
                'currency' => $this->safe_currency_code($feeCurrency),
            );
        }
        $filledAmount = $this->safe_string($order, 'cumQty', '0');
        $filledAmountNumber = $this->parse_number($filledAmount);
        $amount = $this->safe_string($order, 'ordQty');
        $cost = $this->safe_string($order, 'cumAmt');
        $remaining = Precise::string_sub($amount, $filledAmount);
        $average = $filledAmountNumber !== 0 ? Precise::string_div($cost, $filledAmount) : null;
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($order, 'ordId'),
            'clientOrderId' => $this->safe_string($order, 'clOrdId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $this->safe_symbol($this->safe_string_lower($order, 'symbol'), $market),
            'type' => $this->safe_string_lower($order, 'ordType'),
            'timeInForce' => 'GTC',
            'postOnly' => null,
            'side' => $this->safe_string_lower('order', 'side'),
            'price' => $this->safe_number($order, 'ordPrice'),
            'stopPrice' => null,
            'triggerPrice' => null,
            'amount' => $this->parse_number($amount),
            'filled' => $filledAmountNumber,
            'remaining' => $this->parse_number($remaining),
            'average' => $average ? $this->parse_number($average) : null,
            'status' => $this->parse_order_status($this->safe_string_2($order, 'ordStatus', 'ordState')),
            'trades' => null,
            'fee' => $fee,
        ), $market);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'REJECTED' => 'rejected',
            'SUBMITTING' => 'open',
            'SUBMITTED' => 'open',
            'PARTIAL_FILLED' => 'open',
            'CANCELING' => 'canceled',
            'CANCELED' => 'canceled',
            'EXPIRED' => 'expired',
            'STOPPED' => 'closed',
            'FILLED' => 'closed',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all unfilled currently open orders
             * @param {string} $symbol unified $market $symbol
             * @param {int} [$since] the earliest time in ms to fetch open orders for
             * @param {int} [$limit] the maximum number of open order structures to retrieve
             * @param {array} [$params] extra parameters specific to the coinstore api endpoint
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            // $parsedOrders = Async\await($this->fetch_orders($symbol, null, null, $params));
            // $filteredOrders = $this->filter_by($parsedOrders, 'status', 'open');
            // if ($since !== null || $limit !== null) {
            //     return $this->filter_by_since_limit($filteredOrders, $since, $limit);
            // }
            // return $filteredOrders;
            Async\await($this->load_markets());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $market['id'];
            }
            $response = Async\await($this->privateGetApiV2TradeOrderActive (array_merge($request, $params)));
            $data = $this->safe_value($response, 'data');
            if ($since !== null || $limit !== null) {
                $data = $this->filter_by_since_limit($data, $since, $limit);
            }
            return $this->parse_orders($data, $market);
        }) ();
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple closed orders made by the user
             * @param {string} [$symbol] unified market $symbol of the market orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $parsedOrders = Async\await($this->fetch_orders($symbol, null, null, $params));
            $filteredOrders = $this->filter_by_array($parsedOrders, 'status', array( 'canceled', 'rejected', 'expired', 'closed' ), false);
            if ($since !== null || $limit !== null) {
                return $this->filter_by_since_limit($filteredOrders, $since, $limit);
            }
            return $filteredOrders;
        }) ();
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent $trades for a particular $symbol
             * @see https://coinstore-openapi.github.io/en/#get-user-39-s-latest-trade
             * @param {string} $symbol unified $symbol of the $market to fetch $trades for
             * @param {number} [$since] timestamp used to filter out older $trades
             * @param {number} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params=array()] extra parameters specific to the coinstore api endpoint
             * @param {string} [$params->ordId] the order to get $trades for
             * @param {number} [$params->pageNum] which page of $trades to list
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
             */
            Async\await($this->load_markets());
            $this->check_required_symbol('fetchMyTrades', $symbol);
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['pageSize'] = $limit;
            }
            $response = Async\await($this->privateGetApiTradeMatchAccountMatches (array_merge($request, $params)));
            $trades = $this->safe_value($response, 'data', array());
            // $tradesParsed = $this->parse_trades($trades, $market, $since)
            return $this->parse_trades($trades, $market, $since);
        }) ();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = array (), $body = null) {
        /**
         * signs and initiates the request
         * @see https://coinstore-openapi.github.io/en/#signature-authentication
         * @param {string} $path the $path to be appended to the URL
         * @param array('GET' | 'POST') $method extra parameters specific to the coinstore $api endpoint
         * @param {array} [$params] parameters to use for the $path (for v1 symbols) or the query string
         * @param {array} [$headers] $headers to use for the request
         * @param {array} [$body] $body to use for the request
         * @return {array} an associative dictionary of currencies
         */
        $url = $this->$'urls'['api']['spot'];
        $url = $this->implode_hostname($url);
        // v1 $api implodes 'symbol' for some endpoints
        $path = $this->implode_params($path, $params);
        $url .= '/' . $path;
        $params = $this->omit($params, $this->extract_params($path));
        $params = $this->keysort($params);
        $paramString = '';
        $bodyString = '';
        if ($method === 'GET') {
            $paramString = $this->urlencode($params);
        } else {
            $bodyString = json_encode ($params);
        }
        if (strlen($paramString)) {
            $url .= '?' . $paramString;
        }
        $headers['Content-Type'] = 'application/json';
        if ($api === 'private') {
            $this->check_required_credentials();
            $timestamp = $this->milliseconds() + 2000;
            $headers['X-CS-EXPIRES'] = (string) $timestamp;
            $headers['X-CS-APIKEY'] = $this->apiKey;
            $expiresKey = (int) floor($timestamp / 30000);
            $expiresHmac = $this->hmac($this->encode(string) ($expiresKey), $this->encode($this->secret), 'sha256', 'hex');
            $headers['X-CS-SIGN'] = $this->hmac($this->encode($paramString . $bodyString), $this->encode($expiresHmac), 'sha256', 'hex');
        }
        if ($method === 'POST') {
            return array( 'url' => $url, 'method' => $method, 'body' => $bodyString, 'headers' => $headers );
        }
        return array( 'url' => $url, 'method' => $method, 'headers' => $headers );
        // if ($body === 0) {
        // }
        // return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($code !== null) {
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $reason);
        }
        if ($response === null) {
            return null; // fallback to default error handler
        }
        $responseCode = $this->safe_number($response, 'code');
        if ($responseCode !== 0) {
            $message = $this->safe_string($response, 'message');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $responseCode, $message);
            throw new BadRequest($this->id . ' failed with $code ' . $responseCode . ' and $message ' . $message . '. Check your arguments and parameters');
        }
    }
}
