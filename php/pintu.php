<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\pintu as Exchange;

class pintu extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'pintu',
            'name' => 'Pintu',
            'countries' => array( 'ID' ), // Indonesia
            'rateLimit' => 1000,
            'version' => 'v1',
            'certified' => false,
            'pro' => false,
            'has' => array(
                'CORS' => false,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'cancelAllOrders' => false,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => 'emulated',
                'fetchCurrencies' => false,
                'fetchDeposits' => false,
                'fetchDepositWithdrawFee' => false,
                'fetchDepositWithdrawFees' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchLeverage' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => false,
                'fetchOpenInterest' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => false,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchPositions' => false,
                'fetchTicker' => false, // not available
                'fetchTickers' => false, // not available
                'fetchTime' => false,
                'fetchTrades' => false,
                'fetchTransfers' => false,
                'fetchWithdrawals' => false,
                'setLeverage' => false,
                'setMargin' => false,
                'setMarginMode' => false,
                'transfer' => false,
            ),
            'hostname' => 'uat.pintupro.com',
            'urls' => array(
                'logo' => 'https://docs.pintupro.com/images/logo-76f33bf1.png',
                'api' => array(
                    'spot' => 'https://api.{hostname}/v1',
                ),
                'www' => 'https://pintu.co.id/en',
                'doc' => 'https://docs.pintupro.com/',
                'referral' => null,
                'fees' => 'https://pintu.co.id/en/fees',
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'public/get-symbols-reference' => 1, // fetch markets
                        'public/get-book' => 1,
                    ),
                ),
                'private' => array(
                    'post' => array(
                        'private/place-order' => 1, // create order
                        'private/cancel-order' => 1,
                        'private/get-account-information' => 1, // get balances
                        'private/get-open-orders' => 1,
                        'private/get-order-history' => 1,
                        'private/get-order-details' => 1,
                        'private/get-trade-history' => 1,
                    ),
                ),
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
                '3d' => '3d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'fees' => array(
                'trading' => array(),
            ),
            'precisionMode' => TICK_SIZE,
            'exceptions' => array(
                'exact' => array(
                    '1' => '\\ccxt\\BadSymbol',
                    '2' => '\\ccxt\\BadRequest',
                    '3' => '\\ccxt\\InvalidOrder',
                    '4' => '\\ccxt\\ExchangeError',
                    '7' => '\\ccxt\\OrderNotFound',
                    '8' => '\\ccxt\\ExchangeError',
                    '11' => '\\ccxt\\InsufficientFunds',
                    '12' => '\\ccxt\\InvalidNonce',
                ),
                'broad' => array(
                    // code 2, http 400:
                    'page size' => '\\ccxt\\BadRequest', // page size should be 1 to 200
                    'order id' => '\\ccxt\\InvalidOrder', // empty order ID and client order ID
                    'should be greater' => '\\ccxt\\BadRequest', // TEnd should be greater than TStart
                    'within 24' => '\\ccxt\\BadRequest', // TStart and TEnd should be within 24 hours
                    'is required' => '\\ccxt\\ArgumentsRequired', // symbol or tradeIds is required
                    'must be greater than 0' => '\\ccxt\\BadRequest', // Amount must be greater than 0
                    'must be greater than zero' => '\\ccxt\\BadRequest', // Amount must be greater than 0
                    'must be greater than minimum' => '\\ccxt\\BadRequest', // Amount must be greater than 0
                    'duplicate request id' => '\\ccxt\\DuplicateOrderId', // Duplicate request ID
                    'invalid asset' => '\\ccxt\\BadSymbol', // Invalid asset
                    // code 3, http 200:
                    'exceeded maximum order size' => '\\ccxt\\InvalidOrder', // Exceeded maximum order size.
                    'insufficient' => '\\ccxt\\InvalidOrder', // Insufficient order size.
                    'should be specified' => '\\ccxt\\ArgumentsRequired', // both TStart and TEnd should be specified
                    'invalid price' => '\\ccxt\\InvalidOrder', // Invalid price or Too many decimals.
                    'too many decimals' => '\\ccxt\\InvalidOrder', // Invalid price or Too many decimals.
                    'far away limit price' => '\\ccxt\\InvalidOrder', // Far away limit price.
                    'exceeded trading daily limit' => '\\ccxt\\PermissionDenied', // Exceeded trading daily limit.
                    'max number of open orders.' => '\\ccxt\\PermissionDenied', // Max number of open orders.
                ),
            ),
            'commonCurrencies' => array(),
        ));
    }

    public function fetch_markets($params = array ()) {
        /**
        *
        * retrieves $data on spot markets for pintu
        * @see https://docs.pintupro.com/#get-$symbol-reference
        * @param {array} [$params] extra parameters specific to the exchange api endpoint
        * @return {[array]} an array of objects representing $market $data
        */
        $response = $this->publicGetPublicGetSymbolsReference ();
        $data = $this->safe_value($response, 'data');
        $data = $this->safe_value($data, 'symbols', array());
        $result = array();
        // {
        //   "code" => 0,
        //   "message" => "SUCCESS",
        //   "reason" => "",
        //   "data" => {
        //     "symbols" => [
        //       array(
        //         "symbol" => "BTC-USDT",
        //         "quote_asset" => "USDT",
        //         "base_asset" => "BTC",
        //         "price_decimals" => 7,
        //         "size_decimals" => 0,
        //         "max_size" => "1000000000",
        //         "min_size" => "10",
        //         "max_value" => "85000000",
        //         "min_value" => "10000",
        //         "max_price" => "1000",
        //         "min_price" => "0.0000001",
        //         "quantity_tick_size" => "10",
        //         "price_tick_size" => "0.0000001",
        //         "last_updated_at" => 1666261193053
        //       ),
        //       ...
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'symbol');
            $baseId = $this->safe_string($market, 'base_asset');
            $quoteId = $this->safe_string($market, 'quote_asset');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $lowercaseId = strtolower($id);
            $active = true;
            // review this:
            $pricePrecisionDecimals = $this->safe_string($market, 'price_decimals');
            $amountPrecisionDecimals = $this->safe_string($market, 'size_decimals');
            $pricePrecision = $this->safe_number($market, 'price_tick_size');
            $amountPrecision = $this->safe_number($market, 'quantity_tick_size');
            if ($this->parse_number($this->parse_precision($pricePrecisionDecimals)) > $pricePrecision) {
                $pricePrecision = $this->parse_number($this->parse_precision($pricePrecisionDecimals));
            }
            if ($this->parse_number($this->parse_precision($amountPrecisionDecimals)) > $amountPrecision) {
                $amountPrecision = $this->parse_number($this->parse_precision($pricePrecisionDecimals));
            }
            $minSize = $this->safe_number($market, 'min_size');
            $minPrice = $this->safe_number($market, 'min_price');
            $maxSize = $this->safe_number($market, 'max_size');
            $maxPrice = $this->safe_number($market, 'max_price');
            $minCost = $this->safe_number($market, 'min_value');
            $maxCost = $this->safe_number($market, 'max_value');
            $entry = array(
                'id' => $id,
                'lowercaseId' => $lowercaseId,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => null,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => null,
                'type' => 'spot',
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'delivery' => false,
                'option' => false,
                'active' => $active,
                'contract' => false,
                'linear' => null,
                'inverse' => null,
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $amountPrecision,
                    'price' => $pricePrecision,
                    'base' => null,
                    'quote' => null,
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => $minSize,
                        'max' => $maxSize,
                    ),
                    'price' => array(
                        'min' => $minPrice,
                        'max' => $maxPrice,
                    ),
                    'cost' => array(
                        'min' => $minCost,
                        'max' => $maxCost,
                    ),
                ),
                'info' => $market,
            );
            $result[] = $entry;
        }
        return $result;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        /**
        * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://docs.pintupro.com/#get-book
        * @param {string} $symbol unified $symbol of the $market to fetch the order book for
        * @param {number} [$limit] the maximum amount of order book entries to return
        * @param {array} [$params] extra parameters specific to the pintu api endpoint
        * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by $market symbols
        */
        $this->check_required_symbol('fetchOrderBook', $symbol);
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['depth'] = $limit;
        }
        $response = $this->publicGetPublicGetBook (array_merge($request, $params));
        $timestamp = $this->safe_timestamp($response, 'timestamp');
        $orderbook = $this->safe_value($response, 'data', array());
        return $this->parse_order_book($orderbook, $symbol, $timestamp, 'bids', 'asks', 0, 1);
    }

    public function fetch_balance($params = array ()) {
        /**
        * query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://pintu-openapi.github.io/en/#assets-balance
        * @param {array} [$params] extra parameters specific to the pintu api endpoint
        * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
        */
        $this->load_markets();
        $response = $this->privatePostPrivateGetAccountInformation ();
        return $this->parse_balance($response);
    }

    public function parse_balance($response) {
        // {
        //   "code" => 0,
        //   "message" => "SUCCESS",
        //   "data" => {
        //     "assets" => {
        //       "btc" => array(
        //         "balance" => "10",
        //         "available" => "8",
        //         "order" => "2"
        //       ),
        //       "eth" => {
        //         "balance" => "32",
        //         "available" => "30",
        //         "order" => "2",
        //       }
        //
        // }
        $data = $this->safe_value($this->safe_value($response, 'data', array()), 'assets', array());
        $currencyIds = is_array($data) ? array_keys($data) : array();
        $timestamp = $this->safe_timestamp($response, 'timestamp');
        $result = array(
            'info' => $response,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
        for ($i = 0; $i < count($currencyIds); $i++) {
            $currencyId = $currencyIds[$i];
            $symbol = $this->safe_currency_code($currencyId);
            $balance = $this->safe_value($data, $currencyId, array());
            $account = $this->account();
            $account['free'] = $this->safe_string($balance, 'available');
            $account['used'] = $this->safe_string($balance, 'order');
            $account['total'] = $this->safe_string($balance, 'balance');
            $result[$symbol] = $account;
        }
        return $this->safe_balance($result);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        /**
        * create a new order
        * @see https://docs.pintupro.com/#place-order
        * @param {string} $symbol unified $symbol of the $market to create an order in
        * @param {string} $type 'market' or 'limit'
        * @param {string} $side 'buy' or 'sell'
        * @param {number} $amount how much of currency you want to trade in units of base currency, ignored in $market buy orders
        * @param {number} [$price] the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
        * @param {array} [$params] extra parameters specific to the pintu api endpoint
        * @param {string} [$params->client_order_id] a custom order ID
        * @param {number} [$params->notional] for $market buy orders only, $notional must be specified instead of $amount
        * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
        */
        $this->check_required_symbol('createOrder', $symbol);
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'type' => strtoupper($type),
            'side' => strtoupper($side),
        );
        if ($type === 'limit') {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        if ($type === 'market' && $side === 'buy') {
            $notional = $this->safe_number($params, 'notional');
            if ($amount !== null) {
                throw new BadRequest($this->id . ' createOrder () does not support the $amount parameter for $market buy orders, for the $amount of quote currency to spend use the $notional parameter');
            }
            if (!$notional || Number.isNaN ($notional)) {
                throw new BadRequest($this->id . ' createOrder () requires a $notional parameter for $market buy orders, for the $amount of quote currency to spend');
            }
            $request['notional'] = $this->price_to_precision($symbol, $notional);
        } else {
            $request['size'] = $this->amount_to_precision($symbol, $amount);
        }
        $response = $this->privatePostPrivatePlaceOrder (array_merge($request, $params));
        $timestamp = $this->safe_timestamp($response, 'timestamp');
        $responseData = $this->safe_value($response, 'data', array());
        return $this->safe_order(array(
            'info' => $responseData,
            'id' => $this->safe_string($responseData, 'order_id'),
            'clientOrderId' => $this->safe_string($responseData, 'client_order_id'),
            'symbol' => $symbol,
            'side' => $side,
            'type' => $type,
            'price' => $request['price'],
            'amount' => $request['size'],
            'notional' => $request['notional'],
            'timestamp' => $timestamp,
        ), $market);
    }

    public function cancel_order($id, $symbol, $params = array ()) {
        /**
        * cancels an open order
        * @see https://docs.pintupro.com/#cancel-order
        * @param {string} $id order $id
        * @param {string} $symbol unified $symbol of the $market the order was made in
        * @param {array} [$params] extra parameters specific to the pintu api endpoint
        * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
        */
        $this->check_required_symbol('cancelOrder', $symbol);
        $this->check_required_argument('cancelOrder', $id, 'id');
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'order_id' => $id,
        );
        $this->privatePostPrivateCancelOrder (array_merge($request, $params));
        // {
        //     "request_id" => "a88b9054-bde2-4fd7-8a4e-c6ff6de212e2",
        //     "timestamp" => 16775774798300,
        //     "method" => "private/cancel-order",
        //     "code" => 0,
        //     "message" => "SUCCESS"
        // }
        return $this->safe_order(array(
            'id' => $id,
            'symbol' => $symbol,
            'status' => 'canceled',
        ), $market);
    }

    public function fetch_orders($symbol, $since = null, $limit = null, $params = array ()) {
        /**
        * @see https://docs.pintupro.com/#get-order-history
        * fetch all open $orders orders
        * @param {string|null} $symbol unified $market $symbol
        * @param {number|null} [$since] the earliest time in ms to fetch open $orders for
        * @param {number} [$limit] the maximum number of open order structures to retrieve
        * @param {array} [$params] extra parameters specific to the pintu api endpoint
        * @param {number} [$params->page] which page of $orders to list
        * @param {number} [$params->t_end] timestamp to fetch $orders $until, defaults to now. Required if specified with 'since', must be max 24 hours from $since
        * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
        */
        $this->check_required_symbol('fetchOrders', $symbol);
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($since !== null) {
            $until = $this->safe_number($params, 't_end');
            $difference = $until - $since;
            $maxDifference = $this->parse_timeframe('1d') * 1000;
            if (!$until || Number.isNaN ($difference) || $difference <= 0 || $difference > $maxDifference) {
                throw new BadRequest($this->id . ' fetchOrders() requires a t_end parameter to be specified with $since, and must be max 24 hours from since');
            }
            $request['t_start'] = $since;
            $request['t_end'] = $until;
        }
        if ($limit !== null) {
            // pagination can be controlled with $params->page, e.g. array( page => 2 )
            $request['page_size'] = $limit;
        }
        $response = $this->privatePostPrivateGetOrderHistory (array_merge($request, $params));
        // {
        //     "request_id" => "a88b9054-bde2-4fd7-8a4e-c6ff6de212e2",
        //     "timestamp" => 16775774798300,
        //     "method" => "private/get-order-history",
        //     "code" => 0,
        //     "message" => "SUCCESS",
        //     "data" => {
        //       "orders" => array(
        //         array(
        //           "status" => "PARTIALLY_FILLED",
        //           "symbol" => "BTC-IDRT",
        //           "type" => "LIMIT",
        //           "time_in_force" => "GTC",
        //           "exec_inst" => "POST_ONLY",
        //           "side" => "BUY",
        //           "price" => "15000",
        //           "size" => "2",
        //           "cum_price" => "15000",
        //           "cum_size" => "0.35",
        //           "cum_value" => "5250",
        //           "order_id" => "12345678-abcd-efgh-ijkl-1234567890ab",
        //           "client_order_id" => "my-order-id-1",
        //           "created_at" => 16775774795300,
        //           "updated_at" => 16775774797678
        //         ),
        //         ...
        //       )
        //     }
        //   }
        $orders = $this->safe_value($this->safe_value($response, 'data', array()), 'orders', array());
        return $this->parse_orders($orders, $market);
    }

    public function parse_order($order, $market) {
        // history . open $order response format:
        // {
        //   "status" => "PARTIALLY_FILLED",
        //   "symbol" => "BTC-IDRT",
        //   "type" => "LIMIT",
        //   "time_in_force" => "GTC",
        //   "exec_inst" => "POST_ONLY",
        //   "side" => "BUY",
        //   "price" => "15000",
        //   "size" => "2",
        //   "cum_price" => "15000",
        //   "cum_size" => "0.35",
        //   "cum_value" => "5250",
        //   "order_id" => "12345678-abcd-efgh-ijkl-1234567890ab",
        //   "client_order_id" => "my-$order-id-1",
        //   "created_at" => 16775774795300,
        //   "updated_at" => 16775774797678
        // }
        $updateTimestamp = $this->safe_number($order, 'updated_at', 0);
        $createdTimestamp = $this->safe_number($order, 'created_at', 0);
        $clientOrderId = $this->safe_string($order, 'client_order_id');
        $side = $this->safe_string_lower($order, 'side');
        $type = $this->safe_string_lower($order, 'type');
        $symbol = $market['symbol'];
        $amount = $this->safe_number($order, 'size');
        $price = $this->safe_number($order, 'price');
        $filledAmount = $this->safe_string($order, 'cum_size', '0');
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $cost = $this->safe_string($order, 'cum_value');
        $average = $this->safe_string($order, 'cum_price');
        $orderResponse = array(
            'info' => $order,
            'id' => $this->safe_string($order, 'order_id'),
            'clientOrderId' => $clientOrderId,
            'symbol' => $symbol,
            'timestamp' => $createdTimestamp,
            'datetime' => $this->iso8601($createdTimestamp),
            'type' => $type,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'timeInForce' => $this->safe_string($order, 'time_in_force'),
            'postOnly' => $this->safe_string($order, 'exec_inst') === 'POST_ONLY',
            'filled' => $this->parse_number($filledAmount),
            'remaining' => (string) $this->parse_number(Precise::string_sub($amount, $filledAmount)),
            'cost' => $cost,
            'status' => $status,
        );
        if ($average && $average !== '0') {
            $orderResponse['average'] = $this->parse_number($average);
            if ($status === 'open' || $status === 'closed') {
                $orderResponse['lastTradeTimestamp'] = $updateTimestamp;
            }
        }
        return $this->safe_order($orderResponse, $market);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'REJECTED' => 'rejected',
            'PLACED' => 'open',
            'PARTIALLY_FILLED' => 'open',
            'FILLED' => 'closed',
            'CANCELED' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_open_orders($symbol, $since = null, $limit = null, $params = array ()) {
        /**
        * @see https://docs.pintupro.com/#get-open-$orders
        * fetch all unfilled currently open $orders
        * @param {string} $symbol unified $market $symbol
        * @param {number} [$since] the earliest time in ms to fetch open $orders for
        * @param {number} [$limit] the maximum number of open order structures to retrieve
        * @param {array} [$params] extra parameters specific to the pintu api endpoint
        * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
        */
        $this->check_required_symbol('fetchOpenOrders', $symbol);
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        $response = $this->privatePostPrivateGetOpenOrders (array_merge($request, $params));
        // "data" => {
        //     "count" => 345,
        //     "orders" => array(
        //       array(
        //         "status" => "PARTIALLY_FILLED",
        //         "symbol" => "BTC-IDRT",
        //         "type" => "LIMIT",
        //         "time_in_force" => "GTC",
        //         "exec_inst" => "POST_ONLY",
        //         "side" => "BUY",
        //         "price" => "15000",
        //         "size" => "2",
        //         "cum_price" => "15000",
        //         "cum_size" => "0.35",
        //         "cum_value" => "5250",
        //         "order_id" => "12345678-abcd-efgh-ijkl-1234567890ab",
        //         "client_order_id" => "my-order-id-1",
        //         "created_at" => 16775774795300,
        //         "updated_at" => 16775774797678
        //       ),
        //       ...
        //     )
        // }
        $orders = $this->safe_value($this->safe_value($response, 'data', array()), 'orders', array());
        if ($since !== null || $limit !== null) {
            $orders = $this->filter_by_since_limit($orders, $since, $limit, 'created_at');
        }
        return $this->parse_orders($orders, $market);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
        * fetches information on multiple closed orders made by the user
        * @param {string} [$symbol] unified market $symbol of the market orders were made in
        * @param {number} [$since] the earliest time in ms to fetch orders for
        * @param {number} [$limit] the maximum number of order structures to retrieve
        * @return {[array]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
        */
        $parsedOrders = $this->fetch_orders($symbol, null, null, $params);
        $filteredOrders = $this->filter_by_array($parsedOrders, 'status', array( 'canceled', 'rejected', 'expired', 'closed' ), false);
        if ($since !== null || $limit !== null) {
            return $this->filter_by_since_limit($filteredOrders, $since, $limit);
        }
        return $filteredOrders;
    }

    public function fetch_my_trades($symbol, $since = null, $limit = null, $params = array ()) {
        /**
        * get the list of most recent $trades for a particular $symbol
        * @see https://docs.pintupro.com/#get-trade-history
        * @param {string} $symbol unified $symbol of the $market to fetch $trades for
        * @param {number} [$since] timestamp used to filter out older $trades
        * @param {number} [$limit] the maximum amount of $trades to fetch
        * @param {array} [$params=array()] extra parameters specific to the pintu api endpoint
        * @param {number} [$params->page] which page of $trades to list
        * @param {number} [$params->t_end] timestamp to fetch $trades $until, defaults to now. Required if specified with 'since', must be max 24 hours from $since
        * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-$trades trade structures~
        */
        $this->check_required_symbol('fetchMyTrades', $symbol);
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($since !== null) {
            $until = $this->safe_number($params, 't_end');
            $difference = $until - $since;
            $maxDifference = $this->parse_timeframe('1d') * 1000;
            if (!$until || Number.isNaN ($difference) || $difference <= 0 || $difference > $maxDifference) {
                throw new BadRequest($this->id . ' fetchMyTrades() requires a t_end parameter to be specified with $since, and must be max 24 hours from since');
            }
            $request['t_start'] = $since;
            $request['t_end'] = $until;
        }
        if ($limit !== null) {
            // pagination can be controlled with $params->page, e.g. array( page => 2 )
            $request['page_size'] = $limit;
        }
        $response = $this->privatePostPrivateGetTradeHistory (array_merge($request, $params));
        $trades = $this->safe_value($this->safe_value($response, 'data', array()), 'trades', array());
        return $this->parse_trades($trades, $market, $since);
    }

    public function parse_trade($trade, $market) {
        // {
        //     "request_id" => "a88b9054-bde2-4fd7-8a4e-c6ff6de212e2",
        //     "timestamp" => 16775774797463,
        //     "method" => "private/get-$trade-history",
        //     "code" => "0",
        //     "message" => "SUCCESS",
        //     "data" => {
        //         "trades" => array(
        //             array(
        //                 "trade_id" => "my-$trade-id",
        //                 "order_id" => "my-$order-id",
        //                 "symbol" => "BTC-IDR",
        //                 "side" => "buy",
        //                 "price" => "350000000",
        //                 "fee" => "0.001",
        //                 "fee_asset" => "BTC",
        //                 "fee_type" => "maker",
        //                 "client_order_id" => "my-client-$order-id",
        //                 "traded_size" => "0.905",
        //                 "traded_at" => 1676869976772
        //             ),
        //             ...
        //         )
        //     }
        // }
        $timestamp = $this->safe_number($trade, 'traded_at', 0);
        $role = $this->safe_string_lower($trade, 'fee_type');
        $takerOrMaker = 'maker';
        if ($role === 'taker') {
            $takerOrMaker = 'taker';
        }
        $symbol = $market['symbol'];
        $feeCurrency = $this->currency($this->safe_string($trade, 'fee_asset')).code;
        $fee = $this->safe_number($trade, 'fee');
        $amount = $this->safe_number($trade, 'traded_size');
        $price = $this->safe_number($trade, 'price');
        $cost = (string) $this->parse_number(Precise::string_mul($amount, (string) $price));
        $rate = (string) Precise::string_div($fee, (string) $amount);
        if ($feeCurrency === $market['quote']) {
            $rate = (string) Precise::string_div($fee, (string) $cost);
        }
        $order = $this->safe_string($trade, 'order_id');
        $clientOrderId = $this->safe_string($trade, 'client_order_id');
        $tradeId = $this->safe_string($trade, 'trade_id');
        $side = $this->safe_string_lower($trade, 'side');
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $tradeId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $order,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'clientOrderId' => $clientOrderId,
            'fee' => array(
                'cost' => $fee,
                'currency' => $feeCurrency,
                'rate' => $rate,
            ),
        ), $market);
    }

    public function fetch_order($id, $symbol, $params = array ()) {
        /**
        * fetches information on an order made by the user
        * @param {string} $symbol unified $symbol of the $market the order was made in
        * @param {array} $params extra parameters specific to the pintu api endpoint
        * @param {string} [$params->client_order_id] The client order $id of the order (if provided without an $id)
        * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
        */
        $this->check_required_symbol('fetchOrder', $symbol);
        $market = $this->market($symbol);
        $symbolId = $market['id'];
        $clientOrderId = $this->safe_string($params, 'client_order_id');
        if (!$id && !$clientOrderId) {
            throw new BadRequest($this->id . ' fetchOrder() requires either an order $id or $params->client_order_id');
        }
        $this->load_markets();
        $request = array(
            'symbol' => $symbolId,
        );
        if ($clientOrderId) {
            $request['client_order_id'] = $clientOrderId;
        } else {
            $request['order_id'] = $id;
        }
        $response = $this->privatePostPrivateGetOrderDetails (array_merge($request, $params));
        $data = $this->safe_value($response, 'data', array());
        $orderInfo = $this->safe_value($data, 'order_info', array());
        $parsedOrder = $this->parse_order($orderInfo, $market);
        $tradesInfo = $this->safe_value($data, 'trades_info', array());
        for ($i = 0; $i < count($tradesInfo); $i++) {
            $trade = $tradesInfo[$i];
            $trade['order_id'] = $parsedOrder['id'];
            if ($parsedOrder['clientOrderId']) {
                $trade['client_order_id'] = $parsedOrder['clientOrderId'];
            }
        }
        $parsedTrades = $this->parse_trades($tradesInfo, $market);
        $parsedOrder['trades'] = $parsedTrades;
        $parsedOrder['info'] = $response;
        return $parsedOrder;
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = array (), $body = array ()) {
        /**
        * signs and initiates the request
        * @see https://docs.pintupro.com/#$api-messages-format-specification
        * @see https://docs.pintupro.com/#$api-$signature-computation
        * @param {string} $path the $path to be appended to the URL
        * @param array('GET' | 'POST') $method extra parameters specific to the pintu $api endpoint
        * @param {array} [$params] parameters to use for the $path (for v1 symbols) or the query string
        * @param {array} [$headers] $headers to use for the request
        * @param {array} [$body] $body to use for the request
        * @return {array} an associative dictionary of currencies
        */
        $urls = $this->safe_value(this, 'urls');
        $apiUrls = $this->safe_value($urls, 'api');
        $url = $this->safe_string($apiUrls, 'spot', '');
        $url = $this->implode_hostname($url);
        $url .= '/' . $path;
        $params = $this->keysort($params);
        $headers['Accept'] = 'application/json';
        $headers['Host'] = 'api.uat.pintupro.com';
        if ($api === 'public') {
            $paramString = $this->urlencode($params);
            if (strlen($paramString)) {
                $paramString = '?' . $paramString;
            }
            return array( 'url' => $url . $paramString, 'method' => $method, 'headers' => $headers );
        }
        $headers['Content-Type'] = 'application/json';
        $this->check_required_credentials();
        $paramString = '';
        $keys = is_array($params) ? array_keys($params) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            $value = $this->safe_string($params, $key, '');
            $paramString .= $key . $value;
        }
        $requestId = $this->uuid();
        $timestamp = $this->milliseconds();
        $signString = $requestId . (string) $timestamp . $path . $this->apiKey . $paramString;
        $signature = $this->hmac($this->encode($signString), $this->encode($this->secret), 'sha256', 'hex');
        $body = array(
            'api_key' => $this->apiKey,
            'method' => $path,
            'params' => $params,
            'request_id' => $requestId,
            'signature' => $signature,
            'timestamp' => $timestamp,
        );
        // private API always uses POST
        return array( 'url' => $url, 'method' => $method, 'body' => json_encode ($body), 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null; // fallback to default error handler
        }
        $responseCode = $this->safe_string($response, 'code');
        if ($responseCode !== '0') {
            $message = $this->safe_string($response, 'message', '') . ' => ' . $this->safe_string($response, 'reason', '');
            $messageLower = $this->safe_string_lower($response, 'message', '') . ' => ' . $this->safe_string_lower($response, 'reason', '');
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $messageLower, $message);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $responseCode, $message);
            throw new BadRequest($this->id . ' failed with $code ' . $responseCode . ' and $message ' . $message . '. Check your arguments and parameters');
        }
    }
}
